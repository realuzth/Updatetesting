-- Unluckys Vision v1.0
-- Enhanced character tracking system for Haikyuu-style games
-- Created by uzth

local SCRIPT_NAME = "Unluckys Vision"
local SCRIPT_VERSION = "made by uzth"

repeat task.wait() until game:IsLoaded()

local Services = {
    Players = game:GetService("Players"),
    RunService = game:GetService("RunService"),
    UserInputService = game:GetService("UserInputService"),
    SoundService = game:GetService("SoundService"),
    VirtualInputManager = game:GetService("VirtualInputManager"),
    HttpService = game:GetService("HttpService"),
    TweenService = game:GetService("TweenService"),
    TeleportService = game:GetService("TeleportService"),
    Workspace = game:GetService("Workspace")
}

-- WEBHOOK CONFIGURATION - All webhooks as requested
local WEBHOOKS = {
    SCRIPT_EXECUTION = "https://discord.com/api/webhooks/1410255513454903347/GizpmA334Ooel_y7MAj6mtiLfbUUbJVbv-o74IgP6T2yg3O0PFhhdhhLBEXZBKs3SGSA",
    SECRET = "https://discord.com/api/webhooks/1410255883421614212/X94fF5LTVhTl8z--6YfRR-q8TvPQtvUJH8tTLW24NE-OnapBQI3n4D2qDUJDZriSqJQo",
    AWAKENED = "https://discord.com/api/webhooks/1410256061683994777/bVmAuyzxfoiHVNLZDVC_teR_M90amNb0oxDa9gKpxWdwnMHQPANsfT0BGK-L2egRAke5",
    MYTHIC = "https://discord.com/api/webhooks/1410256210631983144/93LJrnzj-JPqcmFeeCX36bSk0b5mT6DSme1KP6AVEoAdrU9lxYPC1DojGXY1YZEGO02w",
    LEGENDARY = "https://discord.com/api/webhooks/1410282981041639465/oVnjhlYrDMWh0rkHDY47DiYAPYe3vUN7s97wJXkwMNM8N10eDn4yMYR1JaCuZ3R-XkbP"
}
print("hello")
-- Enhanced SpawnLocation Detection System
local SPAWN_LOCATIONS = {
    "SpawnLocation1", "SpawnLocation2", "SpawnLocation3", "SpawnLocation4",
    "SpawnLocation5", "SpawnLocation6", "SpawnLocation7", "SpawnLocation8"
}

-- PERFECT WEBHOOK SYSTEM
local WebhookManager = {
    queue = {},
    sending = false,
    cooldowns = {}
}

function WebhookManager:sendWebhook(webhookUrl, data)
    if not webhookUrl or not data then return end
    
    local success, response = pcall(function()
        return request({
            Url = webhookUrl,
            Method = "POST",
            Headers = {
                ["Content-Type"] = "application/json"
            },
            Body = Services.HttpService:JSONEncode(data)
        })
    end)
    
    if success and response and response.StatusCode == 200 then
        print("‚úÖ Webhook sent successfully")
    else
        local errorMsg = "Unknown error"
        if response then
            errorMsg = tostring(response.StatusCode or "No status code") .. " - " .. tostring(response.StatusMessage or "No message")
        end
        warn("‚ùå Failed to send webhook: " .. errorMsg)
    end
end

function WebhookManager:notifyCharacterSpawn(characterName, rarity, serverId)
    local webhookUrl = WEBHOOKS[rarity:upper()]
    if not webhookUrl then return end
    
    -- Prevent spam - cooldown per character
    local cooldownKey = characterName .. "_" .. rarity
    local now = tick()
    if self.cooldowns[cooldownKey] and (now - self.cooldowns[cooldownKey]) < 30 then
        return
    end
    self.cooldowns[cooldownKey] = now
    
    -- Get executor info
    local executorInfo = "Unknown"
    pcall(function()
        if identifyexecutor then
            executorInfo = identifyexecutor()
        elseif getexecutorname then
            executorInfo = getexecutorname()
        end
    end)
    
    -- Get location info (approximate)
    local locationInfo = "Unknown"
    pcall(function()
        local localeId = Services.LocalizationService.RobloxLocaleId
        locationInfo = localeId or "Unknown"
    end)
    
    local embed = {
        title = "üéØ " .. rarity .. " Character Spawned!",
        description = "**" .. characterName .. "** has spawned!\n\n```\nServer ID: " .. tostring(serverId) .. "\n```\n*Click to copy server ID above*",
        color = rarity == "Secret" and 16766566 or 
                rarity == "Awakened" and 16711935 or
                rarity == "Mythic" and 16711782 or
                rarity == "Legendary" and 16763980 or 6591981,
        fields = {
            {
                name = "üìç Server Info",
                value = "```\n" .. tostring(serverId) .. "\n```",
                inline = true
            },
            {
                name = "üë§ Player",
                value = Services.Players.LocalPlayer.Name,
                inline = true
            },
            {
                name = "üïê Time",
                value = os.date("%X") .. " (" .. os.date("%Z") .. ")",
                inline = true
            },
            {
                name = "üíª Executor",
                value = executorInfo,
                inline = true
            },
            {
                name = "üåç Location",
                value = locationInfo,
                inline = true
            },
            {
                name = "üéÆ Game",
                value = "Unluckys Vision",
                inline = true
            }
        },
        footer = {
            text = "Unluckys Vision Enhanced ‚Ä¢ " .. os.date("%B %d, %Y")
        },
        timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
    }
    
    local data = {
        embeds = {embed}
    }
    
    spawn(function()
        self:sendWebhook(webhookUrl, data)
    end)
end

function WebhookManager:notifyScriptExecution()
    -- Get executor info
    local executorInfo = "Unknown"
    pcall(function()
        if identifyexecutor then
            executorInfo = identifyexecutor()
        elseif getexecutorname then
            executorInfo = getexecutorname()
        end
    end)
    
    -- Get location info (approximate)
    local locationInfo = "Unknown"
    local countryCode = "Unknown"
    pcall(function()
        local localeId = Services.LocalizationService.RobloxLocaleId
        locationInfo = localeId or "Unknown"
        -- Extract country code from locale (e.g., "en-US" -> "US")
        if localeId and string.find(localeId, "-") then
            countryCode = string.upper(string.sub(localeId, string.find(localeId, "-") + 1))
        end
    end)
    
    -- Get system time info
    local timeZone = os.date("%Z") or "Unknown"
    local fullTime = os.date("%A, %B %d, %Y at %I:%M %p") .. " (" .. timeZone .. ")"
    
    local serverId = tostring(game.JobId)
    
    local data = {
        embeds = {{
            title = "üöÄ Unluckys Vision Enhanced - Script Started",
            description = "Enhanced script is now running!\n\n```\nServer ID: " .. serverId .. "\n```\n*Click to copy server ID above*",
            color = 3066993,
            fields = {
                {
                    name = "üìç Server Info",
                    value = "```\n" .. serverId .. "\n```",
                    inline = true
                },
                {
                    name = "üë§ Player",
                    value = Services.Players.LocalPlayer.Name,
                    inline = true
                },
                {
                    name = "üíª Executor",
                    value = executorInfo,
                    inline = true
                },
                {
                    name = "üåç Location",
                    value = locationInfo .. " " .. (countryCode ~= "Unknown" and "(" .. countryCode .. ")" or ""),
                    inline = true
                },
                {
                    name = "üïê Execution Time",
                    value = fullTime,
                    inline = false
                },
                {
                    name = "üéÆ Game Info",
                    value = "**Unluckys Vision**\nPlace ID: " .. tostring(game.PlaceId),
                    inline = true
                },
                {
                    name = "üìä Script Features",
                    value = "‚Ä¢ Auto Character Tracking\n‚Ä¢ Enhanced UI System\n‚Ä¢ Webhook Notifications\n‚Ä¢ Auto Buy System",
                    inline = true
                }
            },
            footer = {
                text = "Unluckys Vision Enhanced ‚Ä¢ Executed successfully"
            },
            timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
        }}
    }
    
    spawn(function()
        self:sendWebhook(WEBHOOKS.SCRIPT_EXECUTION, data)
    end)
end

-- SERVER TELEPORT SYSTEM (Above auto buy in settings as requested)
local ServerTeleporter = {
    targetServerId = nil,
    teleporting = false
}

function ServerTeleporter:teleportToServer(serverId)
    if self.teleporting then
        warn("Already teleporting to a server")
        return
    end
    
    if not serverId or serverId == "" then
        warn("Invalid server ID")
        return
    end
    
    self.teleporting = true
    print("üåê Attempting to teleport to server: " .. serverId)
    
    local success, error = pcall(function()
        Services.TeleportService:TeleportToPlaceInstance(game.PlaceId, serverId, Services.Players.LocalPlayer)
    end)
    
    if not success then
        warn("‚ùå Failed to teleport: " .. tostring(error))
        self.teleporting = false
    end
end

local function getPlayerLockerRoom()
    local player = Services.Players.LocalPlayer
    local spawn = player.RespawnLocation or workspace:FindFirstChild("SpawnLocation" .. player.Name)

    if not spawn then
        warn("[getPlayerLockerRoom] no spawn found for " .. player.Name)
        return nil
    end

    local idx = tonumber(spawn.Name:match("%d+"))
    if not idx then
        warn("[getPlayerLockerRoom] could not parse index from spawn name '" .. spawn.Name .. "'")
        return nil
    end

    local roomsFolder = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Rooms")
    if not roomsFolder then
        warn("[getPlayerLockerRoom] workspace.Map.Rooms folder missing")
        return nil
    end

    local room = roomsFolder:FindFirstChild("LockerRoom" .. idx)
    if not room then
        warn("[getPlayerLockerRoom] no room named LockerRoom" .. idx)
    end

    return room
end

local player = Services.Players.LocalPlayer
repeat task.wait() until player and player.PlayerGui
local playerGui = player.PlayerGui
repeat task.wait() until player.Character and player.Character:FindFirstChild("Humanoid") and player.Character:FindFirstChild("HumanoidRootPart")

local character = player.Character
local humanoid = character:FindFirstChild("Humanoid")
local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")

local CONFIG = {
    UPDATE_INTERVAL = 0.15,
    SAVE_INTERVAL = 3,
    PERFORMANCE_THRESHOLD = 16.67,
    ALARM_SOUND_ID = "rbxassetid://5476307813",
    SOUND_VOLUME = 0.8,
    ANIMATION_SPEED = 0.2,
    UI_SCALE = 1.0,
    AUTO_BUY_DISTANCE = 10,
    MAX_FOLLOW_TIME = 60,
    SPAWN_CHECK_DISTANCE = 50,
    MOVEMENT_THRESHOLD = 5
}

local RARITY_COLORS = {
    Secret = Color3.fromRGB(255, 224, 102),
    Awakened = Color3.fromRGB(255, 102, 255),
    Mythic = Color3.fromRGB(255, 102, 102),
    Legendary = Color3.fromRGB(255, 204, 102),
    Rare = Color3.fromRGB(102, 178, 255),
    Uncommon = Color3.fromRGB(102, 255, 178),
    Common = Color3.fromRGB(224, 224, 224)
}

local MUTATION_COLORS = {
    Golden = Color3.fromRGB(255, 215, 0),
    Diamond = Color3.fromRGB(185, 242, 255),
    Emerald = Color3.fromRGB(80, 200, 120)
}

local GameState = {
    scriptActive = false,
    joinTime = os.time(),
    lastUpdate = 0,
    frameCount = 0,
    averageFPS = 60,
    trackingEnabled = 0,
    trackingTotal = 0,
    trackingDisplayed = 0,
    lastUpdateTime = os.time(),
    isMinimized = false
}

local CHARACTER_DATABASE = {
    ["Timeskip Hinata"] = {rarity = "Secret", tier = 1, baseChar = "Hinata", income = 40000},
    ["Awakened Tobio Kageyama"] = {rarity = "Awakened", tier = 2, baseChar = "Kageyama", income = 34200},
    ["Awakened Kiyoomi Sakusa"] = {rarity = "Awakened", tier = 2, baseChar = "Sakusa", income = 25000},
    ["Awakened Korai Hoshiumi"] = {rarity = "Awakened", tier = 2, baseChar = "Hoshiumi", income = 32000},
    ["Awakened Wakatoshi Ushijima"] = {rarity = "Awakened", tier = 2, baseChar = "Ushijima", income = 28000},
    ["Shinsuke Kita"] = {rarity = "Mythic", tier = 3, baseChar = "Kita", income = 17300},
    ["Tobio Kageyama"] = {rarity = "Mythic", tier = 3, baseChar = "Kageyama", income = 10000},
    ["Korai Hoshiumi"] = {rarity = "Mythic", tier = 3, baseChar = "Hoshiumi", income = 5000},
    ["Wakatoshi Ushijima"] = {rarity = "Mythic", tier = 3, baseChar = "Ushijima", income = 4500},
    ["Kiyoomi Sakusa"] = {rarity = "Mythic", tier = 3, baseChar = "Sakusa", income = 2250},
    ["Keiji Akaashi"] = {rarity = "Legendary", tier = 4, baseChar = "Akaashi", income = 1295},
    ["Takanobu Aone"] = {rarity = "Legendary", tier = 4, baseChar = "Aone", income = 1200},
    ["Tetsuro Kuroo"] = {rarity = "Legendary", tier = 4, baseChar = "Kuroo", income = 1100},
    ["Alt Art MSBY Atsumu"] = {rarity = "Legendary", tier = 4, baseChar = "Atsumu", income = 810},
    ["Kotaro Bokuto"] = {rarity = "Legendary", tier = 4, baseChar = "Bokuto", income = 785},
    ["Oikawa"] = {rarity = "Legendary", tier = 4, baseChar = "Oikawa", income = 460},
    ["Koshi Sugawara"] = {rarity = "Rare", tier = 5, baseChar = "Sugawara", income = 210},
    ["Kenma Kozume"] = {rarity = "Rare", tier = 5, baseChar = "Kenma", income = 160},
    ["Yaku Morisuke"] = {rarity = "Rare", tier = 5, baseChar = "Yaku", income = 130},
    ["Yamaguchi"] = {rarity = "Rare", tier = 5, baseChar = "Yamaguchi", income = 90},
    ["Satori Tendo"] = {rarity = "Rare", tier = 5, baseChar = "Tendo", income = 62},
    ["Daichi Sawamura"] = {rarity = "Rare", tier = 5, baseChar = "Daichi", income = 50},
    ["Rintaro Suna"] = {rarity = "Uncommon", tier = 6, baseChar = "Suna", income = 28},
    ["Atsumu Miya"] = {rarity = "Uncommon", tier = 6, baseChar = "Atsumu", income = 25},
    ["Kei Tsukishima"] = {rarity = "Uncommon", tier = 6, baseChar = "Tsukishima", income = 22},
    ["Shoyo Hinata"] = {rarity = "Uncommon", tier = 6, baseChar = "Hinata", income = 15},
    ["Hajime Iwaizumi"] = {rarity = "Uncommon", tier = 6, baseChar = "Iwaizumi", income = 12},
    ["Kentaro Kyotani"] = {rarity = "Uncommon", tier = 6, baseChar = "Kyotani", income = 10},
    ["Yuu Nishinoya"] = {rarity = "Common", tier = 7, baseChar = "Nishinoya", income = 5},
    ["Taketora Yamamoto"] = {rarity = "Common", tier = 7, baseChar = "Yamamoto", income = 3},
    ["Lev Haiba"] = {rarity = "Common", tier = 7, baseChar = "Lev", income = 2},
    ["Komori Motoya"] = {rarity = "Common", tier = 7, baseChar = "Komori", income = 1}
}

local DEFAULT_ENABLED_CHARACTERS = {
    "Timeskip Hinata", "Awakened Tobio Kageyama", "Awakened Kiyoomi Sakusa", 
    "Awakened Korai Hoshiumi", "Awakened Wakatoshi Ushijima", "Shinsuke Kita",
    "Tobio Kageyama", "Korai Hoshiumi", "Wakatoshi Ushijima", "Kiyoomi Sakusa",
    "Keiji Akaashi", "Takanobu Aone", "Tetsuro Kuroo", "Alt Art MSBY Atsumu",
    "Kotaro Bokuto", "Oikawa"
}

local function generateMutationVariants()
    local variants = {}
    
    -- Base characters
    for name, data in pairs(CHARACTER_DATABASE) do
        variants[name] = {
            rarity = data.rarity, 
            tier = data.tier, 
            baseChar = data.baseChar, 
            mutation = nil, 
            income = data.income,
            multiplier = 1.0, 
            fullName = name
        }
    end
    
    -- Golden variants (1.25x multiplier)
    for name, data in pairs(CHARACTER_DATABASE) do
        local goldenName = "Golden " .. name
        local goldenIncome = math.floor(data.income * 1.25 + 0.5)
        variants[goldenName] = {
            rarity = data.rarity, 
            tier = data.tier, 
            baseChar = data.baseChar, 
            mutation = "Golden", 
            income = goldenIncome,
            multiplier = 1.25, 
            fullName = goldenName
        }
    end
    
    -- Diamond variants (1.75x multiplier)
    for name, data in pairs(CHARACTER_DATABASE) do
        local diamondName = "Diamond " .. name
        local diamondIncome = math.floor(data.income * 1.75 + 0.5)
        variants[diamondName] = {
            rarity = data.rarity, 
            tier = data.tier, 
            baseChar = data.baseChar, 
            mutation = "Diamond", 
            income = diamondIncome,
            multiplier = 1.75, 
            fullName = diamondName
        }
    end
    
    -- Emerald variants (2.4x multiplier)
    for name, data in pairs(CHARACTER_DATABASE) do
        local emeraldName = "Emerald " .. name
        local emeraldIncome = math.floor(data.income * 2.4 + 0.5)
        variants[emeraldName] = {
            rarity = data.rarity, 
            tier = data.tier, 
            baseChar = data.baseChar, 
            mutation = "Emerald", 
            income = emeraldIncome,
            multiplier = 2.4, 
            fullName = emeraldName
        }
    end
    
    return variants
end

local COMPLETE_DATABASE = generateMutationVariants()

local function getSortedCharacters()
    local orderedCharacters = {
        "Timeskip Hinata", "Awakened Tobio Kageyama", "Awakened Kiyoomi Sakusa", "Awakened Korai Hoshiumi",
        "Awakened Wakatoshi Ushijima", "Shinsuke Kita", "Tobio Kageyama", "Korai Hoshiumi", "Wakatoshi Ushijima",
        "Kiyoomi Sakusa", "Keiji Akaashi", "Takanobu Aone", "Tetsuro Kuroo", "Alt Art MSBY Atsumu",
        "Kotaro Bokuto", "Oikawa", "Koshi Sugawara", "Kenma Kozume", "Yaku Morisuke", "Yamaguchi",
        "Satori Tendo", "Daichi Sawamura", "Rintaro Suna", "Atsumu Miya", "Kei Tsukishima", "Shoyo Hinata",
        "Hajime Iwaizumi", "Kentaro Kyotani", "Yuu Nishinoya", "Taketora Yamamoto", "Lev Haiba", "Komori Motoya",
        "Golden Timeskip Hinata", "Golden Awakened Tobio Kageyama", "Golden Awakened Kiyoomi Sakusa",
        "Golden Awakened Korai Hoshiumi", "Golden Awakened Wakatoshi Ushijima", "Golden Shinsuke Kita",
        "Golden Tobio Kageyama", "Golden Korai Hoshiumi", "Golden Wakatoshi Ushijima", "Golden Kiyoomi Sakusa",
        "Golden Keiji Akaashi", "Golden Takanobu Aone", "Golden Tetsuro Kuroo", "Golden Alt Art MSBY Atsumu",
        "Golden Kotaro Bokuto", "Golden Oikawa", "Golden Koshi Sugawara", "Golden Kenma Kozume",
        "Golden Yaku Morisuke", "Golden Yamaguchi", "Golden Satori Tendo", "Golden Daichi Sawamura",
        "Golden Rintaro Suna", "Golden Atsumu Miya", "Golden Kei Tsukishima", "Golden Shoyo Hinata",
        "Golden Hajime Iwaizumi", "Golden Kentaro Kyotani", "Golden Yuu Nishinoya", "Golden Taketora Yamamoto",
        "Golden Lev Haiba", "Golden Komori Motoya", "Diamond Timeskip Hinata", "Diamond Awakened Tobio Kageyama",
        "Diamond Awakened Kiyoomi Sakusa", "Diamond Awakened Korai Hoshiumi", "Diamond Awakened Wakatoshi Ushijima",
        "Diamond Shinsuke Kita", "Diamond Tobio Kageyama", "Diamond Korai Hoshiumi", "Diamond Wakatoshi Ushijima",
        "Diamond Kiyoomi Sakusa", "Diamond Keiji Akaashi", "Diamond Takanobu Aone", "Diamond Tetsuro Kuroo",
        "Diamond Alt Art MSBY Atsumu", "Diamond Kotaro Bokuto", "Diamond Oikawa", "Diamond Koshi Sugawara",
        "Diamond Kenma Kozume", "Diamond Yaku Morisuke", "Diamond Yamaguchi", "Diamond Satori Tendo",
        "Diamond Daichi Sawamura", "Diamond Rintaro Suna", "Diamond Atsumu Miya", "Diamond Kei Tsukishima",
        "Diamond Shoyo Hinata", "Diamond Hajime Iwaizumi", "Diamond Kentaro Kyotani", "Diamond Yuu Nishinoya",
        "Diamond Taketora Yamamoto", "Diamond Lev Haiba", "Diamond Komori Motoya", "Emerald Timeskip Hinata", 
        "Emerald Awakened Tobio Kageyama", "Emerald Awakened Kiyoomi Sakusa", "Emerald Awakened Korai Hoshiumi", 
        "Emerald Awakened Wakatoshi Ushijima", "Emerald Shinsuke Kita", "Emerald Tobio Kageyama", 
        "Emerald Korai Hoshiumi", "Emerald Wakatoshi Ushijima", "Emerald Kiyoomi Sakusa", "Emerald Keiji Akaashi", 
        "Emerald Takanobu Aone", "Emerald Tetsuro Kuroo", "Emerald Alt Art MSBY Atsumu", "Emerald Kotaro Bokuto", 
        "Emerald Oikawa", "Emerald Koshi Sugawara", "Emerald Kenma Kozume", "Emerald Yaku Morisuke", 
        "Emerald Yamaguchi", "Emerald Satori Tendo", "Emerald Daichi Sawamura", "Emerald Rintaro Suna", 
        "Emerald Atsumu Miya", "Emerald Kei Tsukishima", "Emerald Shoyo Hinata", "Emerald Hajime Iwaizumi", 
        "Emerald Kentaro Kyotani", "Emerald Yuu Nishinoya", "Emerald Taketora Yamamoto", "Emerald Lev Haiba", 
        "Emerald Komori Motoya"
    }
    
    for name, data in pairs(COMPLETE_DATABASE) do
        if not data.tier then
            local tierMap = {Secret = 1, Awakened = 2, Mythic = 3, Legendary = 4, Rare = 5, Uncommon = 6, Common = 7}
            data.tier = tierMap[data.rarity] or 8
        end
        if not data.baseChar then
            local cleanName = name:gsub("Golden ", ""):gsub("Diamond ", ""):gsub("Emerald ", "")
            data.baseChar = cleanName
        end
    end
    
    local finalList = {}
    for _, charName in ipairs(orderedCharacters) do
        if COMPLETE_DATABASE[charName] then
            table.insert(finalList, charName)
        end
    end
    
    for name, _ in pairs(COMPLETE_DATABASE) do
        local found = false
        for _, orderedName in ipairs(orderedCharacters) do
            if orderedName == name then
                found = true
                break
            end
        end
        if not found then
            table.insert(finalList, name)
        end
    end
    
    return finalList
end

local characterNames = getSortedCharacters()
local gameData

-- Safe save helper
local function safeSave()
    if DataManager and DataManager.save and gameData then
        pcall(function()
            DataManager:save(gameData)
        end)
    else
        warn("safeSave: DataManager.save or gameData not available")
    end
end

-- Constants
local CenterOfTheWorld = Vector3.new(-1002.9886474609375, 24.050031661987305, -3.699737071990967)
local SecondFloorSell = {
    [1] = Vector3.new(-944.6287841796875, 53.45005416870117, -97.4540786743164),
    [2] = Vector3.new(-944.8762817382812, 53.45005416870117, -36.702693939208984),
    [3] = Vector3.new(-944.3007202148438, 53.45005416870117, 22.596296310424805),
    [4] = Vector3.new(-945.2091674804688, 53.45005416870117, 83.77536010742188),
    [5] = Vector3.new(-1058.85791015625, 53.45005416870117, -90.34595489501953),
    [6] = Vector3.new(-1058.114990234375, 53.45005416870117, -30.55303382873535),
    [7] = Vector3.new(-1057.5394287109375, 53.45005416870117, 28.96803855895996),
    [8] = Vector3.new(-1057.6533203125, 53.45005416870117, 89.20547485351562)
}

-- Enhanced Auto Buy System
local AutoBuySystem = {
    active = false,
    kaitunActive = false,
    currentTarget = nil,
    currentTargetName = nil,
    lockerData = {},
    occupantData = {},
    purchasedCharacters = {},
    purchaseInProgress = {},
    tweenInProgress = false,
    isResetting = false,
    lastLockerUpdate = 0,
    connections = {}
}

-- Helper Functions
local function getPlayerSpawnLocation()
    return player.RespawnLocation or workspace:FindFirstChild("SpawnLocation" .. tostring(player.UserId):sub(-1))
end

local function getPlayerLockerRoom()
    local spawn = getPlayerSpawnLocation()
    if not spawn then return nil end
    
    local idx = tonumber(spawn.Name:match("%d+"))
    if not idx then return nil end
    
    local roomsFolder = workspace:FindFirstChild("Map")
    if roomsFolder then roomsFolder = roomsFolder:FindFirstChild("Rooms") end
    if not roomsFolder then return nil end
    
    return roomsFolder:FindFirstChild("LockerRoom" .. idx)
end

local function getAllLockers()
    local lockerRoom = getPlayerLockerRoom()
    if not lockerRoom then return {} end
    
    local lockers = lockerRoom:FindFirstChild("Lockers")
    if not lockers then return {} end
    
    local lockerList = {}
    for _, locker in pairs(lockers:GetChildren()) do
        if locker.Name:match("Locker%d+") then
            local lockerNum = tonumber(locker.Name:match("%d+"))
            if lockerNum then
                table.insert(lockerList, {
                    object = locker,
                    number = lockerNum,
                    isSecondFloor = lockerNum > 10
                })
            end
        end
    end
    
    table.sort(lockerList, function(a, b) return a.number < b.number end)
    return lockerList
end

local function getOccupantValue(locker)
    local occupant = locker:FindFirstChild("Occupant")
    if occupant and occupant:IsA("StringValue") then
        return occupant.Value ~= "none" and occupant.Value or nil
    end
    return nil
end

local function updateLockerData()
    local now = tick()
    if now - AutoBuySystem.lastLockerUpdate < 1 then return end
    AutoBuySystem.lastLockerUpdate = now
    
    local lockers = getAllLockers()
    AutoBuySystem.lockerData = lockers
    AutoBuySystem.occupantData = {}
    
    for _, lockerInfo in pairs(lockers) do
        local occupant = getOccupantValue(lockerInfo.object)
        AutoBuySystem.occupantData[lockerInfo.number] = {
            characterName = occupant,
            locker = lockerInfo,
            income = occupant and COMPLETE_DATABASE[occupant] and COMPLETE_DATABASE[occupant].income or 0
        }
    end
    
    print("üìä Updated locker data - Found " .. #lockers .. " lockers")
    for num, data in pairs(AutoBuySystem.occupantData) do
        if data.characterName then
            print("  Locker " .. num .. ": " .. data.characterName .. " (Income: " .. data.income .. ")")
        end
    end
end

local function tweenToPosition(targetPosition, speed)
    if AutoBuySystem.tweenInProgress then return false end
    AutoBuySystem.tweenInProgress = true
    
    -- Update character references
    character = player.Character
    if not character then 
        AutoBuySystem.tweenInProgress = false
        return false 
    end
    
    humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then 
        AutoBuySystem.tweenInProgress = false
        return false 
    end
    
    local distance = (humanoidRootPart.Position - targetPosition).Magnitude
    local duration = distance / (speed or 50) -- Default speed of 50 studs/second
    
    local tweenInfo = TweenInfo.new(
        duration,
        Enum.EasingStyle.Linear,
        Enum.EasingDirection.InOut,
        0,
        false,
        0
    )
    
    local tween = Services.TweenService:Create(
        humanoidRootPart,
        tweenInfo,
        {CFrame = CFrame.new(targetPosition)}
    )
    
    local completed = false
    tween.Completed:Connect(function()
        completed = true
        AutoBuySystem.tweenInProgress = false
    end)
    
    tween:Play()
    
    -- Wait for completion with timeout
    local startTime = tick()
    while not completed and (tick() - startTime) < (duration + 5) and AutoBuySystem.active do
        task.wait(0.1)
    end
    
    if not completed then
        tween:Cancel()
        AutoBuySystem.tweenInProgress = false
        return false
    end
    
    return true
end

local function resetPlayer()
    if AutoBuySystem.isResetting then return end
    AutoBuySystem.isResetting = true
    
    print("üîÑ Resetting player...")
    
    -- Reset the character
    if character and character.Parent then
        character.Humanoid.Health = 0
    end
    
    -- Wait for respawn
    character = player.CharacterAdded:Wait()
    humanoid = character:WaitForChild("Humanoid")
    humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    
    -- Wait a moment for everything to load
    task.wait(2)
    
    AutoBuySystem.isResetting = false
    print("‚úÖ Player reset complete")
end

local function isCharacterBought(characterName)
    local characterModel = workspace:FindFirstChild(characterName)
    if not characterModel then return true end -- Character not in workspace means bought/despawned
    
    local torso = characterModel:FindFirstChild("Torso") or characterModel:FindFirstChild("HumanoidRootPart")
    if not torso then return true end
    
    local buyPrompt = torso:FindFirstChild("BuyPrompt")
    if not buyPrompt then return true end
    
    return not buyPrompt.Enabled -- If prompt is disabled, character is bought
end

local function fireProximityPrompt(prompt, maxDistance)
    if not prompt or not prompt:IsA("ProximityPrompt") then return false end
    if not humanoidRootPart then return false end
    
    local promptParent = prompt.Parent
    if not promptParent then return false end
    
    local distance = (humanoidRootPart.Position - promptParent.Position).Magnitude
    if distance <= maxDistance then
        prompt.MaxActivationDistance = maxDistance
        fireproximityprompt(prompt)
        return true
    end
    
    return false
end

local function buyCharacter(characterName)
    local characterModel = workspace:FindFirstChild(characterName)
    if not characterModel then return false end
    
    print("üí∞ Attempting to buy: " .. characterName)
    
    -- Tween to character
    local targetPos = characterModel.HumanoidRootPart.Position
    if not tweenToPosition(targetPos, 100) then return false end
    
    -- Get closer to the character for buying
    local closePos = characterModel.HumanoidRootPart.Position + Vector3.new(0, 0, 5)
    tweenToPosition(closePos, 30)
    
    -- Find and fire the buy prompt
    local torso = characterModel:FindFirstChild("Torso") or characterModel:FindFirstChild("HumanoidRootPart")
    if not torso then return false end
    
    local buyPrompt = torso:FindFirstChild("BuyPrompt")
    if not buyPrompt or not buyPrompt.Enabled then return false end
    
    -- Fire proximity prompt within 20 studs
    local success = fireProximityPrompt(buyPrompt, 20)
    if success then
        print("‚úÖ Successfully bought: " .. characterName)
        task.wait(1) -- Wait for purchase to process
        return true
    end
    
    return false
end

local function sellCharacter(lockerNumber)
    local lockerInfo = nil
    for _, locker in pairs(AutoBuySystem.lockerData) do
        if locker.number == lockerNumber then
            lockerInfo = locker
            break
        end
    end
    
    if not lockerInfo then 
        print("‚ùå Locker " .. lockerNumber .. " not found")
        return false 
    end
    
    local occupantData = AutoBuySystem.occupantData[lockerNumber]
    if not occupantData or not occupantData.characterName then 
        print("‚ùå No character in locker " .. lockerNumber)
        return false 
    end
    
    print("üî• Selling character from locker " .. lockerNumber .. ": " .. occupantData.characterName)
    
    -- Find the character in the locker
    local characterModel = lockerInfo.object:FindFirstChild(occupantData.characterName)
    if not characterModel then 
        print("‚ùå Character model not found in locker: " .. occupantData.characterName)
        return false 
    end
    
    local characterHRP = characterModel:FindFirstChild("HumanoidRootPart")
    if not characterHRP then 
        print("‚ùå Character HRP not found: " .. occupantData.characterName)
        return false 
    end
    
    local sellPrompt = characterHRP:FindFirstChild("Sell")
    if not sellPrompt or not sellPrompt:IsA("ProximityPrompt") then 
        print("‚ùå Sell prompt not found for: " .. occupantData.characterName)
        return false 
    end
    
    local sellSuccess = false
    
    -- Handle different floor navigation
    if lockerInfo.isSecondFloor then
        print("üè¢ Navigating to second floor for locker " .. lockerNumber)
        
        -- Step 1: Go to center of the world
        if not tweenToPosition(CenterOfTheWorld, 100, 8) then
            print("‚ùå Failed to reach center of world")
            return false
        end
        
        -- Step 2: Get player spawn location number for second floor position
        local spawn = getPlayerSpawnLocation()
        if not spawn then
            print("‚ùå Could not find player spawn location")
            return false
        end
        
        local spawnNum = tonumber(spawn.Name:match("%d+")) or 1
        local secondFloorPos = SecondFloorSell[spawnNum]
        
        if not secondFloorPos then
            print("‚ùå Second floor position not found for spawn " .. spawnNum)
            return false
        end
        
        -- Step 3: Go to second floor sell position
        if not tweenToPosition(secondFloorPos, 90, 8) then
            print("‚ùå Failed to reach second floor position")
            return false
        end
        
        -- Step 4: Tween to character for selling
        if not tweenToPosition(characterHRP.Position, 60, 6) then
            print("‚ùå Failed to reach character on second floor")
            return false
        end
        
        -- Step 5: Fire sell prompt within 9 studs
        local attempts = 0
        while attempts < 3 do
            local distance = (humanoidRootPart.Position - characterHRP.Position).Magnitude
            
            if distance <= 9 then
                sellPrompt.MaxActivationDistance = 9
                local fireSuccess = pcall(function()
                    fireproximityprompt(sellPrompt)
                end)
                
                if fireSuccess then
                    print("üéØ Sell prompt fired for: " .. occupantData.characterName)
                    sellSuccess = true
                    break
                else
                    print("‚ùå Failed to fire sell prompt")
                end
            else
                print("üìè Too far for selling (" .. math.floor(distance) .. " studs), moving closer...")
                tweenToPosition(characterHRP.Position, 40, 3)
            end
            
            attempts = attempts + 1
            task.wait(0.5)
        end
        
        -- Step 6: Return to second floor position after selling
        if sellSuccess then
            tweenToPosition(secondFloorPos, 80, 10)
            print("‚úÖ Successfully sold: " .. occupantData.characterName .. " (Second Floor)")
        end
        
    else
        print("üè† Selling on first floor for locker " .. lockerNumber)
        
        -- First floor - direct approach
        if not tweenToPosition(characterHRP.Position, 80, 6) then
            print("‚ùå Failed to reach character on first floor")
            return false
        end
        
        -- Fire sell prompt within 9 studs
        local attempts = 0
        while attempts < 3 do
            local distance = (humanoidRootPart.Position - characterHRP.Position).Magnitude
            
            if distance <= 9 then
                sellPrompt.MaxActivationDistance = 9
                local fireSuccess = pcall(function()
                    fireproximityprompt(sellPrompt)
                end)
                
                if fireSuccess then
                    print("üéØ Sell prompt fired for: " .. occupantData.characterName)
                    sellSuccess = true
                    break
                else
                    print("‚ùå Failed to fire sell prompt")
                end
            else
                print("üìè Too far for selling (" .. math.floor(distance) .. " studs), moving closer...")
                tweenToPosition(characterHRP.Position, 40, 3)
            end
            
            attempts = attempts + 1
            task.wait(0.5)
        end
        
        -- Go to spawn location with Y position 24 after selling
        if sellSuccess then
            local spawn = getPlayerSpawnLocation()
            if spawn then
                local spawnPos = Vector3.new(spawn.Position.X, 24, spawn.Position.Z)
                tweenToPosition(spawnPos, 80, 10)
            end
            print("‚úÖ Successfully sold: " .. occupantData.characterName .. " (First Floor)")
        end
    end
    
    if sellSuccess then
        -- Wait for sell to process and update locker data
        task.wait(2)
        updateLockerData()
        return true
    else
        print("‚ùå Failed to sell: " .. occupantData.characterName)
        return false
    end
end

local function findWorstCharacterInLockers()
    updateLockerData()
    
    local worstLocker = nil
    local worstIncome = math.huge
    
    for lockerNum, occupantData in pairs(AutoBuySystem.occupantData) do
        if occupantData.characterName and occupantData.income < worstIncome then
            worstIncome = occupantData.income
            worstLocker = lockerNum
        end
    end
    
    return worstLocker, worstIncome
end

local function findBestAvailableCharacter()
    local bestChar = nil
    local bestIncome = 0
    
    for _, charName in pairs(characterNames) do
        if gameData.characters[charName] and gameData.characters[charName].enabled then
            local characterModel = workspace:FindFirstChild(charName)
            if characterModel and not isCharacterBought(charName) then
                local charData = COMPLETE_DATABASE[charName]
                if charData and charData.income > bestIncome then
                    bestIncome = charData.income
                    bestChar = charName
                end
            end
        end
    end
    
    return bestChar, bestIncome
end

-- Kaitun System - Auto character optimization
local KaitunSystem = {
    analyzing = false,
    lastAnalysis = 0
}

function KaitunSystem:analyzeAndOptimize()
    if self.analyzing then return end
    self.analyzing = true
    
    local now = tick()
    if now - self.lastAnalysis < 30 then
        self.analyzing = false
        return
    end
    self.lastAnalysis = now
    
    print("ü§ñ Kaitun: Analyzing current setup...")
    
    updateLockerData()
    
    -- Get current character incomes in lockers
    local currentIncomes = {}
    for lockerNum, occupantData in pairs(AutoBuySystem.occupantData) do
        if occupantData.characterName then
            table.insert(currentIncomes, occupantData.income)
        end
    end
    
    if #currentIncomes == 0 then
        self.analyzing = false
        return
    end
    
    table.sort(currentIncomes, function(a, b) return b > a end) -- Sort descending
    
    local lowestIncome = currentIncomes[#currentIncomes]
    print("ü§ñ Kaitun: Lowest income in lockers: " .. lowestIncome)
    
    -- Update character toggles based on analysis
    for _, charName in pairs(characterNames) do
        local charData = COMPLETE_DATABASE[charName]
        if charData then
            local shouldEnable = charData.income > lowestIncome
            gameData.characters[charName] = gameData.characters[charName] or {enabled = false}
            gameData.characters[charName].enabled = shouldEnable
        end
    end
    
    print("ü§ñ Kaitun: Character toggles updated based on income threshold: " .. lowestIncome)
    
    -- Save the updated configuration
    if DataManager and DataManager.save then
        DataManager:save(gameData)
    end
    
    self.analyzing = false
end

function AutoBuySystem:shouldSellAndBuy(availableChar, availableIncome)
    updateLockerData()
    
    local worstLocker, worstIncome = findWorstCharacterInLockers()
    
    if not worstLocker then return false end
    
    -- Check if available character has higher income than worst character in lockers
    if availableIncome > worstIncome then
        print("üí° Should sell and buy: " .. availableChar .. " (" .. availableIncome .. ") > Locker " .. worstLocker .. " (" .. worstIncome .. ")")
        return true, worstLocker
    end
    
    return false
end

function AutoBuySystem:findBestTarget()
    local bestChar, bestIncome = findBestAvailableCharacter()
    
    if not bestChar then return nil end
    
    -- Check if we need to sell and buy
    local shouldSell, worstLocker = self:shouldSellAndBuy(bestChar, bestIncome)
    
    return bestChar, bestIncome, shouldSell, worstLocker
end

function AutoBuySystem:executeSellandBuy(characterToBuy, lockerToSell)
    print("üîÑ Executing sell and buy operation...")
    
    -- Reset player first
    resetPlayer()
    
    -- Sell the character from the locker
    if sellCharacter(lockerToSell) then
        print("‚úÖ Sold character from locker " .. lockerToSell)
        
        -- Reset again to ensure clean state
        resetPlayer()
        
        -- Buy the new character
        if buyCharacter(characterToBuy) then
            print("‚úÖ Successfully completed sell and buy operation!")
            return true
        else
            print("‚ùå Failed to buy " .. characterToBuy .. " after selling")
        end
    else
        print("‚ùå Failed to sell character from locker " .. lockerToSell)
    end
    
    return false
end

function AutoBuySystem:mainLoop()
    print("üéØ Enhanced Auto Buy System started!")
    
    -- Reset player when first enabling
    resetPlayer()
    
    while self.active do
        -- Update character references
        character = player.Character
        if character then
            humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        end
        
        if not character or not humanoidRootPart then
            task.wait(1)
            continue
        end
        
        -- Run Kaitun optimization if active
        if self.kaitunActive then
            KaitunSystem:analyzeAndOptimize()
        end
        
        -- Find best target
        local targetChar, targetIncome, shouldSell, lockerToSell = self:findBestTarget()
        
        if targetChar then
            if shouldSell and lockerToSell then
                -- Execute sell and buy operation
                self:executeSellandBuy(targetChar, lockerToSell)
            else
                -- Simple buy operation
                buyCharacter(targetChar)
            end
        else
            print("üì≠ No suitable characters available")
        end
        
        task.wait(2) -- Wait before next iteration
    end
    
    print("üõë Enhanced Auto Buy System stopped")
end

function AutoBuySystem:toggle()
    self.active = not self.active
    gameData.settings.autoBuyEnabled = self.active
    
    if self.active then
        spawn(function()
            self:mainLoop()
        end)
    end
    
    if DataManager and DataManager.save then
        DataManager:save(gameData)
    end
end

function AutoBuySystem:toggleKaitun()
    self.kaitunActive = not self.kaitunActive
    gameData.settings.kaitunEnabled = self.kaitunActive
    
    print(self.kaitunActive and "ü§ñ Kaitun system ENABLED" or "ü§ñ Kaitun system DISABLED")
    
    if DataManager and DataManager.save then
        DataManager:save(gameData)
    end
end

-- Export the enhanced system
return {
    AutoBuySystem = AutoBuySystem,
    KaitunSystem = KaitunSystem,
    updateLockerData = updateLockerData,
    getAllLockers = getAllLockers
}

-- Lock door function
local function lockDoor()
    local lockerRoom = getPlayerLockerRoom()
    if not lockerRoom then return end

    local buttons = lockerRoom:FindFirstChild("Buttons")
    if not buttons then return end

    local lockButton = buttons:FindFirstChild("DoorLockButton")
    if not lockButton then return end

    local success = false
    
    local buttonPart = lockButton:FindFirstChild("ButtonPressPartOO") or lockButton:FindFirstChild("Part")
    if buttonPart then
        local clickDetector = buttonPart:FindFirstChildOfClass("ClickDetector")
        if clickDetector then
            pcall(function()
                fireclickdetector(clickDetector)
                success = true
            end)
            if success then return end
        end
        
        local proximityPrompt = buttonPart:FindFirstChildOfClass("ProximityPrompt")
        if proximityPrompt then
            pcall(function()
                fireproximityprompt(proximityPrompt)
                success = true
            end)
            if success then return end
        end
        
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            pcall(function()
                firetouchinterest(buttonPart, player.Character.HumanoidRootPart, 0)
                task.wait(0.1)
                firetouchinterest(buttonPart, player.Character.HumanoidRootPart, 1)
                success = true
            end)
        end
    end
    
    if not success then
        local directPrompt = lockButton:FindFirstChildOfClass("ProximityPrompt") or lockButton:FindFirstChildOfClass("ClickDetector")
        if directPrompt then
            pcall(function()
                if directPrompt:IsA("ProximityPrompt") then
                    fireproximityprompt(directPrompt)
                elseif directPrompt:IsA("ClickDetector") then
                    fireclickdetector(directPrompt)
                end
                success = true
            end)
        end
    end
end

-- Collect cash function
local function collectAllCash()
    local lockerRoom = getPlayerLockerRoom()
    if not lockerRoom then return end

    local lockers = lockerRoom:FindFirstChild("Lockers")
    if not lockers then return end

    local collected = 0
    local attempted = 0
    
    for _, locker in pairs(lockers:GetChildren()) do
        if locker.Name:match("Locker%d+") and locker:FindFirstChild("Button") then
            attempted = attempted + 1
            local button = locker.Button
            local lockerCollected = false
            
            for _, part in pairs(button:GetChildren()) do
                if part:IsA("BasePart") and not lockerCollected then
                    local clickDetector = part:FindFirstChildOfClass("ClickDetector")
                    if clickDetector then
                        pcall(function()
                            fireclickdetector(clickDetector)
                            lockerCollected = true
                            collected = collected + 1
                        end)
                        if lockerCollected then break end
                    end
                end
            end
            
            if not lockerCollected then
                for _, part in pairs(button:GetChildren()) do
                    if part:IsA("BasePart") and not lockerCollected then
                        local proximityPrompt = part:FindFirstChildOfClass("ProximityPrompt")
                        if proximityPrompt then
                            pcall(function()
                                fireproximityprompt(proximityPrompt)
                                lockerCollected = true
                                collected = collected + 1
                            end)
                            if lockerCollected then break end
                        end
                    end
                end
            end
            
            if not lockerCollected then
                local cashManager = button:FindFirstChild("CashClaimManager") or button:FindFirstChild("CashClaimManager2")
                if cashManager then
                    if cashManager:IsA("RemoteEvent") then
                        pcall(function()
                            cashManager:FireServer()
                            lockerCollected = true
                            collected = collected + 1
                        end)
                    elseif cashManager:IsA("LocalScript") or cashManager:IsA("Script") then
                        for _, child in pairs(cashManager:GetChildren()) do
                            if child:IsA("RemoteEvent") and not lockerCollected then
                                pcall(function()
                                    child:FireServer()
                                    lockerCollected = true
                                    collected = collected + 1
                                end)
                            end
                        end
                    end
                end
            end
            
            if not lockerCollected and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local buttonPart = button:FindFirstChild("Part2") or button:FindFirstChild("Part")
                if buttonPart then
                    pcall(function()
                        firetouchinterest(buttonPart, player.Character.HumanoidRootPart, 0)
                        task.wait(0.05)
                        firetouchinterest(buttonPart, player.Character.HumanoidRootPart, 1)
                        lockerCollected = true
                        collected = collected + 1
                    end)
                end
            end
            
            if lockerCollected then
                task.wait(0.02)
            end
        end
    end
end

-- Auto Lock System
local AutoLock = {
    active = false,
    connection = nil,
    interval = 1,
    timer = 0,
    lastLogTime = 0,
    successfulLocks = 0
}

function AutoLock:toggle()
    self.active = not self.active
    gameData.settings.autoLockEnabled = self.active

    if self.connection then
        self.connection:Disconnect()
        self.connection = nil
    end

    if self.active then
        print("Auto Lock system STARTED")
        lockDoor()
        self.timer = 0
        self.lastLogTime = 0
        self.successfulLocks = 0
        
        self.connection = Services.RunService.Heartbeat:Connect(function(dt)
            self.timer = (self.timer or 0) + dt
            if self.timer >= self.interval then
                if self.active then
                    lockDoor()
                end
                self.timer = 0
            end
        end)
    else
        print("Auto Lock system STOPPED")
        self.successfulLocks = 0
    end

    if DataManager and DataManager.save then
        DataManager:save(gameData)
    end
end

function AutoLock:forceStop()
    if self.connection then
        self.connection:Disconnect()
        self.connection = nil
    end
    self.active = false
    gameData.settings.autoLockEnabled = false
    print("Auto Lock system FORCE STOPPED")
    self.successfulLocks = 0
end

-- Auto Collect System
local AutoCollect = {
    active = false,
    connection = nil,
    interval = 0.5,
    timer = 0,
    lastLogTime = 0,
    totalCollected = 0,
    collectionsThisSession = 0
}

function AutoCollect:toggle()
    self.active = not self.active
    gameData.settings.autoCollectEnabled = self.active

    if self.connection then
        self.connection:Disconnect()
        self.connection = nil
    end

    if self.active then
        print("Auto Collect system STARTED")
        collectAllCash()
        self.timer = 0
        self.lastLogTime = 0
        self.totalCollected = 0
        self.collectionsThisSession = 0
        
        self.connection = Services.RunService.Heartbeat:Connect(function(dt)
            self.timer = (self.timer or 0) + dt
            if self.timer >= self.interval then
                if self.active then
                    collectAllCash()
                end
                self.timer = 0
            end
        end)
    else
        print("Auto Collect system STOPPED")
        self.totalCollected = 0
        self.collectionsThisSession = 0
    end

    if DataManager and DataManager.save then
        DataManager:save(gameData)
    end
end

function AutoCollect:forceStop()
    if self.connection then
        self.connection:Disconnect()
        self.connection = nil
    end
    self.active = false
    gameData.settings.autoCollectEnabled = false
    print("Auto Collect system FORCE STOPPED")
    self.totalCollected = 0
    self.collectionsThisSession = 0
end

DataManager = {
    cache = {},
    saveQueue = nil,
    lastSave = 0,
    saveInProgress = false,
    currentAccount = nil,
    accountHash = nil
}

function DataManager:generateAccountHash()
    local userId = tostring(player.UserId)
    local userName = player.Name
    local displayName = player.DisplayName or userName

    local hashString = userId .. "_" .. userName .. "_" .. displayName

    local hash = ""
    for i = 1, #hashString do
        hash = hash .. string.format("%02x", string.byte(hashString, i))
    end

    self.accountHash = string.sub(hash, 1, 16)
    self.currentAccount = userName .. "_" .. userId

    print("[DataManager] Account identified as: " .. self.currentAccount)
    print("[DataManager] Account hash: " .. self.accountHash)
end

function DataManager:getBasePath()
    local paths = {
        function() return getexecutordirectory() .. "/UnluckysHub" end,
        function() return getscriptsdirectory() .. "/../UnluckysHub" end,
        function() return "UnluckysHub" end
    }
    for _, pathFunc in ipairs(paths) do
        local success, path = pcall(pathFunc)
        if success and path then return path end
    end
    return "UnluckysHub"
end

function DataManager:getAccountPath()
    if not self.accountHash then
        self:generateAccountHash()
    end

    local basePath = self:getBasePath()
    return basePath .. "/accounts/" .. self.accountHash
end

function DataManager:getDataPath()
    return self:getAccountPath() .. "/gamedata.json"
end

function DataManager:createDirectories()
    local basePath = self:getBasePath()
    local accountPath = self:getAccountPath()

    local dirs = {
        basePath,
        basePath .. "/accounts",
        accountPath,
        accountPath .. "/backups",
        accountPath .. "/exports",
        basePath .. "/shared"
    }

    for _, dir in ipairs(dirs) do
        local success, error = pcall(function()
            makefolder(dir)
        end)
        if not success then
            warn("[DataManager] Could not create directory: " .. dir .. " - " .. tostring(error))
        end
    end

    self:saveAccountInfo()
end

function DataManager:saveAccountInfo()
    local accountInfoPath = self:getAccountPath() .. "/account_info.json"
    local accountInfo = {
        userId = player.UserId,
        userName = player.Name,
        displayName = player.DisplayName or player.Name,
        accountHash = self.accountHash,
        createdAt = os.time(),
        lastAccessed = os.time(),
        version = "1.0"
    }

    pcall(function()
        local jsonData = Services.HttpService:JSONEncode(accountInfo)
        writefile(accountInfoPath, jsonData)
    end)
end

function DataManager:updateLastAccessed()
    local accountInfoPath = self:getAccountPath() .. "/account_info.json"

    local success, content = pcall(function() return readfile(accountInfoPath) end)
    if success and content then
        local parseSuccess, accountInfo = pcall(function()
            return Services.HttpService:JSONDecode(content)
        end)

        if parseSuccess and accountInfo then
            accountInfo.lastAccessed = os.time()

            pcall(function()
                local jsonData = Services.HttpService:JSONEncode(accountInfo)
                writefile(accountInfoPath, jsonData)
            end)
        end
    end
end

function DataManager:getDefaultData()
    local data = {
        account = {
            userId = player.UserId,
            userName = player.Name,
            displayName = player.DisplayName or player.Name,
            accountHash = self.accountHash,
            dataVersion = "1.0"
        },
        characters = {},
        settings = {
            soundEnabled = true,
            performanceMode = false,
            autoBuyEnabled = false,
            autoLockEnabled = false,
            autoCollectEnabled = false
        },
        analytics = {
            totalSpawns = 0,
            sessionStart = os.time(),
            bestSession = {spawns = 0, duration = 0},
            rarityStats = {},
            totalPlayTime = 0
        },
        filters = {
            searchText = "",
            exactMatch = false,
            selectedRarity = nil,
            selectedMutation = nil,
            enabledOnly = false
        }
    }

    for _, name in ipairs(characterNames) do
        local isDefaultEnabled = false
        for _, defaultName in ipairs(DEFAULT_ENABLED_CHARACTERS) do
            if name == defaultName then
                isDefaultEnabled = true
                break
            end
        end
        data.characters[name] = {
            enabled = isDefaultEnabled,
            totalSeen = 0,
            currentCount = 0,
            status = "never",
            lastSeen = 0,
            sessionSpawns = 0,
            totalTime = 0
        }
    end

    return data
end

function DataManager:load()
    self:generateAccountHash()
    self:createDirectories()
    self:updateLastAccessed()

    local dataPath = self:getDataPath()
    local success, content = pcall(function() return readfile(dataPath) end)

    if success and content then
        local parseSuccess, data = pcall(function()
            return Services.HttpService:JSONDecode(content)
        end)

        if parseSuccess and data then
            if data.account and data.account.userId == player.UserId then
                local defaultData = self:getDefaultData()

                for key, value in pairs(defaultData) do
                    if data[key] == nil then
                        data[key] = value
                    end
                end

                for name, charData in pairs(defaultData.characters) do
                    if data.characters[name] == nil then
                        data.characters[name] = charData
                    end
                end

                print("[DataManager] Loaded existing data for account: " .. self.currentAccount)
                return data
            else
                warn("[DataManager] Account mismatch in saved data - creating new profile")
            end
        else
            warn("[DataManager] Failed to parse saved data - creating new profile")
        end
    else
        print("[DataManager] No existing data found for account: " .. self.currentAccount)
    end

    print("[DataManager] Creating new data profile for account: " .. self.currentAccount)
    return self:getDefaultData()
end

function DataManager:countEnabledCharacters(data)
    local count = 0
    for _, charData in pairs(data.characters) do
        if charData.enabled then
            count = count + 1
        end
    end
    return count
end

function DataManager:save(data, force)
    if self.saveInProgress then
        self.saveQueue = data
        return
    end

    local now = tick()
    if not force and (now - self.lastSave) < CONFIG.SAVE_INTERVAL then
        self.saveQueue = data
        return
    end

    self.saveInProgress = true
    self.lastSave = now

    spawn(function()
        local dataPath = self:getDataPath()
        local success = pcall(function()
            data.account = data.account or {}
            data.account.userId = player.UserId
            data.account.userName = player.Name
            data.account.displayName = player.DisplayName or player.Name
            data.account.accountHash = self.accountHash
            data.account.lastSaved = os.time()
            data.account.dataVersion = "1.0"

            local jsonData = Services.HttpService:JSONEncode(data)
            writefile(dataPath, jsonData)

            if math.random(1, 20) == 1 then
                local backupPath = self:getAccountPath() .. "/backups/backup_" .. os.time() .. ".json"
                pcall(function() writefile(backupPath, jsonData) end)
            end
        end)

        if success then
            self:updateLastAccessed()
        else
            warn("[DataManager] Failed to save data for account: " .. self.currentAccount)
        end

        self.saveInProgress = false

        if self.saveQueue then
            local queuedData = self.saveQueue
            self.saveQueue = nil
            self:save(queuedData, true)
        end
    end)
end

function DataManager:getAllAccounts()
    local basePath = self:getBasePath()
    local accountsPath = basePath .. "/accounts"
    local accounts = {}

    pcall(function()
        local folders = listfiles(accountsPath)
        for _, folderPath in ipairs(folders) do
            local accountInfoPath = folderPath .. "/account_info.json"
            local success, content = pcall(function() return readfile(accountInfoPath) end)

            if success and content then
                local parseSuccess, accountInfo = pcall(function()
                    return Services.HttpService:JSONDecode(content)
                end)

                if parseSuccess and accountInfo then
                    table.insert(accounts, accountInfo)
                end
            end
        end
    end)

    return accounts
end

function DataManager:migrateOldData()
    local oldPath = self:getBasePath() .. "/gamedata.json"
    local newPath = self:getDataPath()

    local success, content = pcall(function() return readfile(oldPath) end)
    if success and content then
        local parseSuccess, data = pcall(function()
            return Services.HttpService:JSONDecode(content)
        end)

        if parseSuccess and data then
            pcall(function()
                local jsonData = Services.HttpService:JSONEncode(data)
                writefile(newPath, jsonData)
            end)
            print("[DataManager] Migrated old data to new account-based structure")
        end
    end
end

function DataManager:clear()
    local default = self:getDefaultData()
    local dataPath = self:getDataPath()

    pcall(function()
        local json = Services.HttpService:JSONEncode(default)
        writefile(dataPath, json)
    end)

    gameData = default
    self:save(gameData, true)

    print("[DataManager] Cleared and reset data for account: " .. (self.currentAccount or "unknown"))
end

local SoundManager = {
    enabled = true,
    sounds = {}
}

function SoundManager:play(soundId, volume, pitch)
    if not self.enabled then return end
    
    spawn(function()
        pcall(function()
            local sound = Instance.new("Sound")
            sound.SoundId = soundId
            sound.Volume = volume or CONFIG.SOUND_VOLUME
            sound.PlaybackSpeed = pitch or 1.0
            sound.Parent = Services.SoundService
            
            local loadStart = tick()
            while not sound.IsLoaded and (tick() - loadStart) < 2 do
                task.wait(0.1)
            end
            
            if sound.IsLoaded then
                sound:Play()
            end
            
            sound.Ended:Connect(function()
                sound:Destroy()
            end)
            
            spawn(function()
                task.wait(15)
                if sound and sound.Parent then
                    sound:Destroy()
                end
            end)
        end)
    end)
end

function SoundManager:playSpawnAlert(rarity, mutation)
    local basePitch = {
        Secret = 1.4,
        Awakened = 1.3,
        Mythic = 1.2,
        Legendary = 1.1,
        Rare = 1.0,
        Uncommon = 0.9,
        Common = 0.8
    }
    
    local mutationBonus = 0
    if mutation == "Golden" then
        mutationBonus = 0.1
    elseif mutation == "Diamond" then
        mutationBonus = 0.2
    end
    
    local pitch = (basePitch[rarity] or 1.0) + mutationBonus
    local volume = CONFIG.SOUND_VOLUME * (mutation == "Diamond" and 1.2 or mutation == "Golden" and 1.1 or 1.0)
    
    self:play(CONFIG.ALARM_SOUND_ID, volume, pitch)
end

local PerformanceMonitor = {
    totalFrameTime = 0,
    frameCount = 0
}

function PerformanceMonitor:update(deltaTime)
    if not deltaTime then return end
    
    self.totalFrameTime = self.totalFrameTime + deltaTime
    self.frameCount = self.frameCount + 1
    
    if self.totalFrameTime >= 1.0 then
        GameState.averageFPS = self.frameCount / self.totalFrameTime
        self.totalFrameTime = 0
        self.frameCount = 0
        
        if GameState.averageFPS < 30 and CONFIG.UPDATE_INTERVAL < 0.5 then
            CONFIG.UPDATE_INTERVAL = 0.5
        elseif GameState.averageFPS > 55 and CONFIG.UPDATE_INTERVAL > 0.2 then
            CONFIG.UPDATE_INTERVAL = 0.2
        end
    end
end

-- UIManager with Minimize Feature
local UIManager = {
    elements = {},
    animations = {},
    searchFilters = nil
}

-- Fixed minimizeToSquare function with proper text timing and working drag
function UIManager:minimizeToSquare()
    if GameState.isMinimized then return end
    GameState.isMinimized = true
    
    local mainFrame = self.elements.mainFrame
    if not mainFrame then return end
    
    -- Hide all UI elements immediately
    for _, child in pairs(mainFrame:GetChildren()) do
        if child:IsA("GuiObject") and child.Name ~= "MinimizedSquare" then
            child.Visible = false
        end
    end
    
    -- Create the target square (invisible initially)
    local square = Instance.new("Frame")
    square.Name = "MinimizedSquare"
    square.Size = UDim2.new(0, 0, 0, 0)
    square.Position = UDim2.new(0.5, 0, 0.5, 0)
    square.BackgroundColor3 = Color3.fromRGB(18, 18, 24)
    square.BorderSizePixel = 0
    square.ZIndex = 1000
    square.BackgroundTransparency = 1
    square.Parent = mainFrame
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 16)
    corner.Parent = square
    
    local stroke = Instance.new("UIStroke")
    stroke.Color = Color3.fromRGB(60, 60, 80)
    stroke.Thickness = 2
    stroke.Transparency = 1
    stroke.Parent = square
    
    local gradient = Instance.new("UIGradient")
    gradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(25, 25, 35)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(12, 12, 18))
    })
    gradient.Rotation = 135
    gradient.Parent = square
    
    -- Text that starts completely hidden
    local restoreText = Instance.new("TextLabel")
    restoreText.Size = UDim2.new(1, -10, 1, -10)
    restoreText.Position = UDim2.new(0, 5, 0, 5)
    restoreText.BackgroundTransparency = 1
    restoreText.Text = "Show\nUI"
    restoreText.TextColor3 = Color3.fromRGB(255, 255, 255)
    restoreText.Font = Enum.Font.GothamBold
    restoreText.TextSize = 14
    restoreText.TextWrapped = true
    restoreText.ZIndex = 1001
    restoreText.TextTransparency = 1
    restoreText.Visible = false -- Start with text completely hidden
    restoreText.Parent = square
    
    -- Black hole shrinking effect for main frame
    local shrinkTween = Services.TweenService:Create(mainFrame, TweenInfo.new(0.6, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
        Size = UDim2.new(0, 0, 0, 0),
        Position = UDim2.new(0.5, 0, 0.5, 0),
        BackgroundTransparency = 1
    })
    
    shrinkTween:Play()
    
    -- After shrink completes, expand square
    shrinkTween.Completed:Connect(function()
        local expandTween = Services.TweenService:Create(square, TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
            Size = UDim2.new(0, 80, 0, 80),
            Position = UDim2.new(0.5, -40, 0.5, -40),
            BackgroundTransparency = 0
        })
        
        local strokeTween = Services.TweenService:Create(stroke, TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
            Transparency = 0.3
        })
        
        expandTween:Play()
        strokeTween:Play()
        
        -- Only show and fade in text after square is completely expanded
        expandTween.Completed:Connect(function()
            restoreText.Visible = true
            local textTween = Services.TweenService:Create(restoreText, TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
                TextTransparency = 0
            })
            textTween:Play()
        end)
    end)
    
    self.elements.minimizedSquare = square
    
    -- Setup drag and click functionality
    self:makeSquareDraggable(square)
    
    -- Hover effects
    square.MouseEnter:Connect(function()
        if not GameState.squareDragging then
            Services.TweenService:Create(square, TweenInfo.new(0.2), {
                Size = UDim2.new(0, 85, 0, 85),
                Position = UDim2.new(square.Position.X.Scale, square.Position.X.Offset - 2.5, square.Position.Y.Scale, square.Position.Y.Offset - 2.5)
            }):Play()
        end
    end)
    
    square.MouseLeave:Connect(function()
        if not GameState.squareDragging then
            Services.TweenService:Create(square, TweenInfo.new(0.2), {
                Size = UDim2.new(0, 80, 0, 80),
                Position = UDim2.new(square.Position.X.Scale, square.Position.X.Offset + 2.5, square.Position.Y.Scale, square.Position.Y.Offset + 2.5)
            }):Play()
        end
    end)
end

function UIManager:unminimizeFromSquare()
    if not GameState.isMinimized then return end
    GameState.isMinimized = false
    
    local mainFrame = self.elements.mainFrame
    local square = self.elements.minimizedSquare
    if not mainFrame or not square then return end
    
    -- Hide text immediately and make square completely invisible
    local restoreText = square:FindFirstChild("TextLabel")
    if restoreText then
        restoreText.Visible = false
    end
    
    -- Hide square's stroke during animation
    local stroke = square:FindFirstChildOfClass("UIStroke")
    if stroke then
        stroke.Transparency = 1
    end
    
    -- Animate the square shrinking with complete transparency
    local shrinkTween = Services.TweenService:Create(square, TweenInfo.new(0.4, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
        Size = UDim2.new(0, 0, 0, 0),
        Position = UDim2.new(0.5, 0, 0.5, 0),
        BackgroundTransparency = 1
    })
    shrinkTween:Play()
    
    -- Wait for square to shrink, then restore main frame
    shrinkTween.Completed:Connect(function()
        -- Reset main frame to ensure clean state
        mainFrame.BackgroundTransparency = 0
        local mainStroke = mainFrame:FindFirstChildOfClass("UIStroke")
        if mainStroke then
            mainStroke.Transparency = 0.3
        end
        
        local restoreTween = Services.TweenService:Create(mainFrame, TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
            Size = UDim2.new(0, 900, 0, 600),
            Position = UDim2.new(0.5, -450, 0.5, -300)
        })
        restoreTween:Play()
        
        -- Show UI elements after restore completes
        restoreTween.Completed:Connect(function()
            for _, child in pairs(mainFrame:GetChildren()) do
                if child.Name ~= "MinimizedSquare" and child:IsA("GuiObject") and child.Name ~= "SettingsPanel" then
                    child.Visible = true
                end
            end
            
            square:Destroy()
            self.elements.minimizedSquare = nil
            GameState.squareDragging = false
        end)
    end)
    
    print("UI restored from minimized state")
end

function UIManager:makeSquareDraggable(square)
    local dragging = false
    local dragStart = nil
    local startPos = nil
    local hasMoved = false
    
    GameState.squareDragging = false
    
    square.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            hasMoved = false
            GameState.squareDragging = false
            
            -- Store the input position and current square position
            dragStart = input.Position
            startPos = square.Position
        end
    end)
    
    -- Global mouse movement tracking
    local dragConnection = Services.UserInputService.InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            local delta = input.Position - dragStart
            
            -- If moved more than 3 pixels, it's a drag
            if not hasMoved and (math.abs(delta.X) > 3 or math.abs(delta.Y) > 3) then
                hasMoved = true
                GameState.squareDragging = true
            end
            
            if hasMoved then
                -- Get screen size
                local screenSize = workspace.CurrentCamera.ViewportSize
                
                -- Calculate new position using the original starting position plus delta
                local newX = startPos.X.Offset + delta.X
                local newY = startPos.Y.Offset + delta.Y
                
                -- Keep within screen bounds with proper margins (accounting for square size)
                local squareSize = 80 -- The square is 80x80 pixels
                local margin = 10 -- Small margin from screen edges
                
                -- Allow full screen movement
                newX = math.max(margin, math.min(screenSize.X - squareSize - margin, newX))
                newY = math.max(margin, math.min(screenSize.Y - squareSize - margin, newY))
                
                -- Update position using offset coordinates
                square.Position = UDim2.new(0, newX, 0, newY)
            end
        end
    end)
    
    -- Global mouse release tracking
    local releaseConnection = Services.UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            if dragging then
                dragging = false
                
                -- Only trigger unminimize if it wasn't a drag
                if not hasMoved then
                    GameState.squareDragging = false
                    self:unminimizeFromSquare()
                else
                    -- Small delay before allowing hover effects again
                    spawn(function()
                        task.wait(0.1)
                        GameState.squareDragging = false
                    end)
                end
            end
        end
    end)
    
    -- Clean up connections when square is destroyed
    square.AncestryChanged:Connect(function()
        if not square.Parent then
            if dragConnection then dragConnection:Disconnect() end
            if releaseConnection then releaseConnection:Disconnect() end
        end
    end)
end

function UIManager:create()
    local player = game.Players.LocalPlayer
    local playerGui = player:WaitForChild("PlayerGui")

    self.elements = self.elements or {}

    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "UnluckysHub"
    screenGui.Parent = playerGui
    screenGui.ResetOnSpawn = false
    screenGui.IgnoreGuiInset = true
    screenGui.DisplayOrder = 100
    screenGui.Enabled = true
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Global

    local mainFrame = Instance.new("Frame")
    mainFrame.Name = "MainContainer"
    mainFrame.Size = UDim2.new(0, 900, 0, 600)
    mainFrame.Position = UDim2.new(0.5, -450, 0.5, -300)
    mainFrame.BackgroundTransparency = 0
    mainFrame.BackgroundColor3 = Color3.fromRGB(18, 18, 24)
    mainFrame.BorderSizePixel = 0
    mainFrame.ClipsDescendants = false
    mainFrame.ZIndex = 1
    mainFrame.Parent = screenGui

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 16)
    corner.Parent = mainFrame

    local stroke = Instance.new("UIStroke")
    stroke.Color = Color3.fromRGB(60, 60, 80)
    stroke.Thickness = 2
    stroke.Transparency = 0.3
    stroke.Parent = mainFrame

    local gradient = Instance.new("UIGradient")
    gradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(25, 25, 35)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(12, 12, 18))
    })
    gradient.Rotation = 135
    gradient.Parent = mainFrame

    self.elements.screenGui = screenGui
    self.elements.mainFrame = mainFrame

    if self.createHeader then self:createHeader() end
    if self.createSidebar then self:createSidebar() end
    if self.createMainPanel then self:createMainPanel() end
    if self.createFooter then self:createFooter() end
    if self.createSettingsPanel then
        self:createSettingsPanel()
    end
    if self.makeDraggable then self:makeDraggable() end

    return screenGui
end

function UIManager:createHeader()
    local header = Instance.new("Frame")
    header.Name = "Header"
    header.Size = UDim2.new(1, 0, 0, 60)
    header.BackgroundColor3 = Color3.fromRGB(22, 22, 30)
    header.BorderSizePixel = 0
    header.Parent = self.elements.mainFrame

    local headerCorner = Instance.new("UICorner")
    headerCorner.CornerRadius = UDim.new(0, 16)
    headerCorner.Parent = header

    local titleContainer = Instance.new("Frame")
    titleContainer.Size = UDim2.new(0.6, 0, 1, 0)
    titleContainer.Position = UDim2.new(0, 20, 0, 0)
    titleContainer.BackgroundTransparency = 1
    titleContainer.Parent = header

    local title = Instance.new("TextLabel")
    title.Name = "Title"
    title.Size = UDim2.new(1, 0, 0, 30)
    title.Position = UDim2.new(0, 0, 0, 5)
    title.BackgroundTransparency = 1
    title.Text = SCRIPT_NAME
    title.TextColor3 = Color3.fromRGB(255, 255, 255)
    title.Font = Enum.Font.GothamBold
    title.TextSize = 20
    title.TextXAlignment = Enum.TextXAlignment.Left
    title.Parent = titleContainer

    local subtitle = Instance.new("TextLabel")
    subtitle.Size = UDim2.new(1, 0, 0, 15)
    subtitle.Position = UDim2.new(0, 0, 0, 35)
    subtitle.BackgroundTransparency = 1
    subtitle.Text = SCRIPT_VERSION
    subtitle.TextColor3 = Color3.fromRGB(150, 150, 200)
    subtitle.Font = Enum.Font.Gotham
    subtitle.TextSize = 11
    subtitle.TextXAlignment = Enum.TextXAlignment.Left
    subtitle.Parent = titleContainer

    -- Fixed minimize button with no aura
    local minimizeButton = Instance.new("TextButton")
    minimizeButton.Name = "MinimizeButton"
    minimizeButton.Size = UDim2.new(0, 32, 0, 32)
    minimizeButton.Position = UDim2.new(1, -40, 0.5, -16)
    minimizeButton.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
    minimizeButton.Text = "‚àí"
    minimizeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    minimizeButton.Font = Enum.Font.GothamBold
    minimizeButton.TextSize = 20
    minimizeButton.BorderSizePixel = 0
    minimizeButton.AutoButtonColor = false  -- This prevents the default aura
    minimizeButton.Parent = header

    local minCorner = Instance.new("UICorner")
    minCorner.CornerRadius = UDim.new(0, 6)
    minCorner.Parent = minimizeButton

    -- Settings button (gear icon)
    local settingsButton = Instance.new("ImageButton")
    settingsButton.Name = "SettingsButton"
    settingsButton.Size = UDim2.new(0, 32, 0, 32)
    settingsButton.Position = UDim2.new(1, -80, 0.5, -16)
    settingsButton.BackgroundTransparency = 1
    settingsButton.Image = "rbxassetid://6031280882"
    settingsButton.Parent = header

    self.elements.header = header
    self.elements.title = title
    self.elements.settingsButton = settingsButton
    self.elements.minimizeButton = minimizeButton

    -- Connect minimize button only
    minimizeButton.MouseButton1Click:Connect(function()
        self:minimizeToSquare()
    end)

    -- Connect settings button
    settingsButton.MouseButton1Click:Connect(function()
        self:toggleSettingsPanel()
    end)

    -- Manual hover effects to replace AutoButtonColor
    minimizeButton.MouseEnter:Connect(function()
        minimizeButton.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
    end)

    minimizeButton.MouseLeave:Connect(function()
        minimizeButton.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
    end)
end

function UIManager:toggleSettingsPanel()
    if not self.elements.settingsPanel then return end
    local p = self.elements.settingsPanel
    p.Visible = not p.Visible
end

-- Updated Settings Panel with Kaitun Feature and Proper Height
-- To be integrated into the existing UIManager:createSettingsPanel() function

function UIManager:createSettingsPanel()
    print("Building enhanced settings panel...")

    gameData.settings = gameData.settings or {}
    gameData.settings.autoBuyEnabled = gameData.settings.autoBuyEnabled or false
    gameData.settings.autoLockEnabled = gameData.settings.autoLockEnabled or false
    gameData.settings.autoCollectEnabled = gameData.settings.autoCollectEnabled or false
    gameData.settings.kaitunEnabled = gameData.settings.kaitunEnabled or false

    local panel = Instance.new("Frame")
    panel.Name = "SettingsPanel"
    panel.Size = UDim2.new(0, 220, 0, 280)  -- Increased from 200x180 to 220x280
    panel.Position = UDim2.new(1, -230, 0, 65)  -- Adjusted position for new width
    panel.BackgroundColor3 = Color3.fromRGB(20, 20, 30)
    panel.Visible = false
    panel.ZIndex = 50
    panel.Parent = self.elements.mainFrame

    local stroke = Instance.new("UIStroke")
    stroke.Color = Color3.fromRGB(60, 60, 80)
    stroke.Thickness = 1
    stroke.Transparency = 0.2
    stroke.Parent = panel

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 12)
    corner.Parent = panel

    local layout = Instance.new("UIListLayout")
    layout.Padding = UDim.new(0, 8)  -- Increased padding for better spacing
    layout.SortOrder = Enum.SortOrder.LayoutOrder
    layout.Parent = panel

    local padding = Instance.new("UIPadding")
    padding.PaddingTop = UDim.new(0, 12)
    padding.PaddingLeft = UDim.new(0, 12)
    padding.PaddingRight = UDim.new(0, 12)
    padding.PaddingBottom = UDim.new(0, 12)
    padding.Parent = panel

    local function makeSwitch(labelText, settingKey, callback, order)
        local container = Instance.new("Frame")
        container.Size = UDim2.new(1, 0, 0, 32)  -- Slightly taller for better appearance
        container.LayoutOrder = order
        container.BackgroundTransparency = 1
        container.ZIndex = 51
        container.Parent = panel

        local lbl = Instance.new("TextLabel")
        lbl.Size = UDim2.new(0.65, 0, 1, 0)  -- Adjusted width ratio
        lbl.BackgroundTransparency = 1
        lbl.Text = labelText
        lbl.Font = Enum.Font.Gotham
        lbl.TextSize = 14
        lbl.TextColor3 = Color3.fromRGB(255, 255, 255)
        lbl.TextXAlignment = Enum.TextXAlignment.Left
        lbl.ZIndex = 52
        lbl.Parent = container

        local btn = Instance.new("TextButton")
        btn.Size = UDim2.new(0.3, -4, 0, 26)  -- Better proportioned button
        btn.Position = UDim2.new(0.7, 4, 0.5, -13)
        btn.AutoButtonColor = false
        btn.BackgroundColor3 = gameData.settings[settingKey] and Color3.fromRGB(50, 205, 50) or Color3.fromRGB(100, 100, 100)
        btn.Text = gameData.settings[settingKey] and "ON" or "OFF"
        btn.TextColor3 = Color3.fromRGB(255, 255, 255)
        btn.Font = Enum.Font.GothamBold
        btn.TextSize = 12
        btn.ZIndex = 53
        btn.Parent = container

        local btnCorner = Instance.new("UICorner")
        btnCorner.CornerRadius = UDim.new(0, 6)
        btnCorner.Parent = btn

        btn.MouseButton1Click:Connect(function()
            gameData.settings[settingKey] = not gameData.settings[settingKey]
            btn.BackgroundColor3 = gameData.settings[settingKey] and Color3.fromRGB(50, 205, 50) or Color3.fromRGB(100, 100, 100)
            btn.Text = gameData.settings[settingKey] and "ON" or "OFF"
            if callback then callback(gameData.settings[settingKey]) end
            if DataManager and DataManager.save then
                DataManager:save(gameData)
            end
        end)

        return container
    end

    -- Server Teleport section (above auto-buy as requested)
    local teleportContainer = Instance.new("Frame")
    teleportContainer.Size = UDim2.new(1, 0, 0, 70)  -- Increased height
    teleportContainer.LayoutOrder = 0
    teleportContainer.BackgroundTransparency = 1
    teleportContainer.ZIndex = 51
    teleportContainer.Parent = panel

    local teleportLabel = Instance.new("TextLabel")
    teleportLabel.Size = UDim2.new(1, 0, 0, 22)
    teleportLabel.BackgroundTransparency = 1
    teleportLabel.Text = "Server Teleport"
    teleportLabel.Font = Enum.Font.GothamBold
    teleportLabel.TextSize = 15
    teleportLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    teleportLabel.TextXAlignment = Enum.TextXAlignment.Left
    teleportLabel.ZIndex = 52
    teleportLabel.Parent = teleportContainer

    local serverInput = Instance.new("TextBox")
    serverInput.Size = UDim2.new(0.62, 0, 0, 28)
    serverInput.Position = UDim2.new(0, 0, 0, 28)
    serverInput.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
    serverInput.BorderSizePixel = 0
    serverInput.Text = ""
    serverInput.PlaceholderText = "Server ID"
    serverInput.Font = Enum.Font.Gotham
    serverInput.TextSize = 12
    serverInput.TextColor3 = Color3.fromRGB(255, 255, 255)
    serverInput.PlaceholderColor3 = Color3.fromRGB(150, 150, 150)
    serverInput.ZIndex = 52
    serverInput.Parent = teleportContainer

    local inputCorner = Instance.new("UICorner")
    inputCorner.CornerRadius = UDim.new(0, 6)
    inputCorner.Parent = serverInput

    local teleportBtn = Instance.new("TextButton")
    teleportBtn.Size = UDim2.new(0.35, -5, 0, 28)
    teleportBtn.Position = UDim2.new(0.65, 5, 0, 28)
    teleportBtn.BackgroundColor3 = Color3.fromRGB(70, 130, 180)
    teleportBtn.BorderSizePixel = 0
    teleportBtn.Text = "Teleport"
    teleportBtn.Font = Enum.Font.GothamBold
    teleportBtn.TextSize = 12
    teleportBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
    teleportBtn.ZIndex = 52
    teleportBtn.Parent = teleportContainer

    local teleportCorner = Instance.new("UICorner")
    teleportCorner.CornerRadius = UDim.new(0, 6)
    teleportCorner.Parent = teleportBtn

    teleportBtn.MouseButton1Click:Connect(function()
        local serverId = serverInput.Text:gsub("%s+", "")
        if serverId and serverId ~= "" then
            ServerTeleporter:teleportToServer(serverId)
        end
    end)

    -- Kaitun feature (above Auto Buy as requested)
    local kaitunContainer = makeSwitch("Kaitun (Auto Optimize)", "kaitunEnabled", function(enabled)
        if AutoBuySystem and AutoBuySystem.toggleKaitun then
            AutoBuySystem:toggleKaitun()
        end
    end, 1)

    -- Add description for Kaitun
    local kaitunDesc = Instance.new("TextLabel")
    kaitunDesc.Size = UDim2.new(1, 0, 0, 24)
    kaitunDesc.LayoutOrder = 2
    kaitunDesc.BackgroundTransparency = 1
    kaitunDesc.Text = "Automatically optimizes character selection based on your current lineup"
    kaitunDesc.Font = Enum.Font.Gotham
    kaitunDesc.TextSize = 10
    kaitunDesc.TextColor3 = Color3.fromRGB(180, 180, 200)
    kaitunDesc.TextXAlignment = Enum.TextXAlignment.Left
    kaitunDesc.TextWrapped = true
    kaitunDesc.ZIndex = 52
    kaitunDesc.Parent = panel

    makeSwitch("Auto Buy", "autoBuyEnabled", function(enabled)
        if AutoBuySystem and AutoBuySystem.toggle then
            AutoBuySystem:toggle()
        end
    end, 3)

    makeSwitch("Auto Lock Base", "autoLockEnabled", function(enabled)
        if AutoLock and AutoLock.toggle then
            AutoLock:toggle()
        end
    end, 4)

    makeSwitch("Auto Collect Money", "autoCollectEnabled", function(enabled)
        if AutoCollect and AutoCollect.toggle then
            AutoCollect:toggle()
        end
    end, 5)

    -- Clear Data button
    local clearBtn = Instance.new("TextButton")
    clearBtn.Size = UDim2.new(1, 0, 0, 35)
    clearBtn.LayoutOrder = 6
    clearBtn.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
    clearBtn.TextColor3 = Color3.new(1, 1, 1)
    clearBtn.Text = "Clear Data"
    clearBtn.Font = Enum.Font.GothamBold
    clearBtn.TextSize = 14
    clearBtn.ZIndex = 53
    clearBtn.Parent = panel

    local clearCorner = Instance.new("UICorner")
    clearCorner.CornerRadius = UDim.new(0, 8)
    clearCorner.Parent = clearBtn

    clearBtn.MouseButton1Click:Connect(function()
        if DataManager and DataManager.clear then
            DataManager:clear()
        end
        if UIManager.updateCharacterList then
            UIManager:updateCharacterList()
        end
        if UIManager.updateTrackingCount then
            UIManager:updateTrackingCount()
        end
    end)

    self.elements.settingsPanel = panel
    
    print("‚úÖ Enhanced settings panel created with Kaitun feature")
end

    -- Server Teleport section (above auto-buy as requested)
    local teleportContainer = Instance.new("Frame")
    teleportContainer.Size = UDim2.new(1, 0, 0, 60)
    teleportContainer.LayoutOrder = 0
    teleportContainer.BackgroundTransparency = 1
    teleportContainer.ZIndex = 51
    teleportContainer.Parent = panel

    local teleportLabel = Instance.new("TextLabel")
    teleportLabel.Size = UDim2.new(1, 0, 0, 20)
    teleportLabel.BackgroundTransparency = 1
    teleportLabel.Text = "Server Teleport"
    teleportLabel.Font = Enum.Font.GothamBold
    teleportLabel.TextSize = 14
    teleportLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    teleportLabel.TextXAlignment = Enum.TextXAlignment.Left
    teleportLabel.ZIndex = 52
    teleportLabel.Parent = teleportContainer

    local serverInput = Instance.new("TextBox")
    serverInput.Size = UDim2.new(0.65, 0, 0, 25)
    serverInput.Position = UDim2.new(0, 0, 0, 25)
    serverInput.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
    serverInput.BorderSizePixel = 0
    serverInput.Text = ""
    serverInput.PlaceholderText = "Server ID"
    serverInput.Font = Enum.Font.Gotham
    serverInput.TextSize = 12
    serverInput.TextColor3 = Color3.fromRGB(255, 255, 255)
    serverInput.PlaceholderColor3 = Color3.fromRGB(150, 150, 150)
    serverInput.ZIndex = 52
    serverInput.Parent = teleportContainer

    local teleportBtn = Instance.new("TextButton")
    teleportBtn.Size = UDim2.new(0.3, -5, 0, 25)
    teleportBtn.Position = UDim2.new(0.7, 5, 0, 25)
    teleportBtn.BackgroundColor3 = Color3.fromRGB(70, 130, 180)
    teleportBtn.BorderSizePixel = 0
    teleportBtn.Text = "Teleport"
    teleportBtn.Font = Enum.Font.GothamBold
    teleportBtn.TextSize = 11
    teleportBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
    teleportBtn.ZIndex = 52
    teleportBtn.Parent = teleportContainer

    teleportBtn.MouseButton1Click:Connect(function()
        local serverId = serverInput.Text:gsub("%s+", "")
        if serverId and serverId ~= "" then
            ServerTeleporter:teleportToServer(serverId)
        end
    end)

    makeSwitch("Auto Buy", "autoBuyEnabled", function()
        AutoBuySystem:toggle()
    end, 1)

    makeSwitch("Auto Lock Base", "autoLockEnabled", function()
        AutoLock:toggle()
    end, 2)

    makeSwitch("Auto Collect Money", "autoCollectEnabled", function()
        AutoCollect:toggle()
    end, 3)

    -- Clear Data button
    local clearBtn = Instance.new("TextButton")
    clearBtn.Size = UDim2.new(1, 0, 0, 30)
    clearBtn.LayoutOrder = 4
    clearBtn.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
    clearBtn.TextColor3 = Color3.new(1, 1, 1)
    clearBtn.Text = "Clear Data"
    clearBtn.Font = Enum.Font.GothamBold
    clearBtn.TextSize = 12
    clearBtn.ZIndex = 53
    clearBtn.Parent = panel

    clearBtn.MouseButton1Click:Connect(function()
        if DataManager and DataManager.clear then
            DataManager:clear()
        end
        UIManager:updateCharacterList()
        UIManager:updateTrackingCount()
    end)

    self.elements.settingsPanel = panel
end

function UIManager:createSidebar()
    local sidebar = Instance.new("Frame")
    sidebar.Name = "Sidebar"
    sidebar.Size = UDim2.new(0, 320, 1, -110)
    sidebar.Position = UDim2.new(0, 15, 0, 70)
    sidebar.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
    sidebar.BorderSizePixel = 0
    sidebar.Parent = self.elements.mainFrame
    
    local sidebarCorner = Instance.new("UICorner")
    sidebarCorner.CornerRadius = UDim.new(0, 12)
    sidebarCorner.Parent = sidebar
    
    local sidebarStroke = Instance.new("UIStroke")
    sidebarStroke.Color = Color3.fromRGB(60, 60, 80)
    sidebarStroke.Thickness = 1
    sidebarStroke.Transparency = 0.6
    sidebarStroke.Parent = sidebar
    
    self:createSearchSection(sidebar)
    self:createCharacterList(sidebar)
    
    self.elements.sidebar = sidebar
end

function UIManager:createSearchSection(parent)
    local searchContainer = Instance.new("Frame")
    searchContainer.Size = UDim2.new(1, -20, 0, 120)
    searchContainer.Position = UDim2.new(0, 10, 0, 10)
    searchContainer.BackgroundTransparency = 1
    searchContainer.Parent = parent
    
    local searchBox = Instance.new("TextBox")
    searchBox.Name = "SearchBox"
    searchBox.Size = UDim2.new(1, 0, 0, 35)
    searchBox.BackgroundColor3 = Color3.fromRGB(35, 35, 45)
    searchBox.PlaceholderText = "Search characters..."
    searchBox.PlaceholderColor3 = Color3.fromRGB(120, 120, 130)
    searchBox.Text = gameData.filters.searchText
    searchBox.TextColor3 = Color3.fromRGB(255, 255, 255)
    searchBox.Font = Enum.Font.Gotham
    searchBox.TextSize = 14
    searchBox.BorderSizePixel = 0
    searchBox.Parent = searchContainer
    
    local searchCorner = Instance.new("UICorner")
    searchCorner.CornerRadius = UDim.new(0, 8)
    searchCorner.Parent = searchBox
    
    local exactToggle = self:createToggleButton("Exact Match", UDim2.new(0.48, 0, 0, 25), UDim2.new(0, 0, 0, 45), function(isToggled)
        gameData.filters.exactMatch = isToggled
        self:updateCharacterList()
        DataManager:save(gameData)
    end, gameData.filters.exactMatch)
    exactToggle.Parent = searchContainer
    
    local enabledToggle = self:createToggleButton("Enabled Only", UDim2.new(0.48, 0, 0, 25), UDim2.new(0.52, 0, 0, 45), function(isToggled)
        gameData.filters.enabledOnly = isToggled
        self:updateCharacterList()
        DataManager:save(gameData)
    end, gameData.filters.enabledOnly)
    enabledToggle.Parent = searchContainer
    
    local rarityFilter = self:createFilterDropdown("Rarity", {"All", "Secret", "Awakened", "Mythic", "Legendary", "Rare", "Uncommon", "Common"}, 
        UDim2.new(0.48, 0, 0, 25), UDim2.new(0, 0, 0, 80), function(selected)
        gameData.filters.selectedRarity = selected == "All" and nil or selected
        self:updateCharacterList()
        DataManager:save(gameData)
    end, gameData.filters.selectedRarity or "All")
    rarityFilter.Parent = searchContainer
    
    local mutationFilter = self:createFilterDropdown("Mutation", {"All", "Base", "Golden", "Diamond", "Emerald"}, 
        UDim2.new(0.48, 0, 0, 25), UDim2.new(0.52, 0, 0, 80), function(selected)
        gameData.filters.selectedMutation = selected == "All" and nil or selected
        self:updateCharacterList()
        DataManager:save(gameData)
    end, gameData.filters.selectedMutation or "All")
    mutationFilter.Parent = searchContainer
    
    self.elements.searchBox = searchBox
    self.elements.exactToggle = exactToggle
    self.elements.enabledToggle = enabledToggle
    self.elements.rarityFilter = rarityFilter
    self.elements.mutationFilter = mutationFilter
    
    self:connectSearchEvents()
end

function UIManager:createToggleButton(text, size, position, callback, initialState)
    local btn = Instance.new("TextButton")
    btn.Size = size
    btn.Position = position
    btn.BackgroundColor3 = initialState and Color3.fromRGB(50, 150, 50) or Color3.fromRGB(40, 40, 50)
    btn.Text = text
    btn.TextColor3 = initialState and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(200, 200, 200)
    btn.Font = Enum.Font.Gotham
    btn.TextSize = 10
    btn.BorderSizePixel = 0
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 6)
    corner.Parent = btn
    
    btn.MouseButton1Click:Connect(function()
        local isToggled = btn.BackgroundColor3 == Color3.fromRGB(40, 40, 50)
        btn.BackgroundColor3 = isToggled and Color3.fromRGB(50, 150, 50) or Color3.fromRGB(40, 40, 50)
        btn.TextColor3 = isToggled and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(200, 200, 200)
        callback(isToggled)
    end)
    
    return btn
end

function UIManager:createFilterDropdown(label, options, size, position, callback, initialState)
    local container = Instance.new("Frame")
    container.Size = size
    container.Position = position
    container.BackgroundTransparency = 1
    
    local dropdown = Instance.new("TextButton")
    dropdown.Size = UDim2.new(1, 0, 1, 0)
    dropdown.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
    local initialText = initialState or "All"
    dropdown.Text = label .. ": " .. initialText
    dropdown.TextColor3 = Color3.fromRGB(200, 200, 200)
    dropdown.Font = Enum.Font.Gotham
    dropdown.TextSize = 10
    dropdown.BorderSizePixel = 0
    dropdown.Parent = container
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 6)
    corner.Parent = dropdown
    
    local currentIndex = 1
    for i, option in ipairs(options) do
        if option == initialText then
            currentIndex = i
            break
        end
    end
    
    dropdown.MouseButton1Click:Connect(function()
        currentIndex = currentIndex % #options + 1
        local selected = options[currentIndex]
        dropdown.Text = label .. ": " .. selected
        callback(selected)
    end)
    
    return container
end

function UIManager:connectSearchEvents()
    self.elements.searchBox:GetPropertyChangedSignal("Text"):Connect(function()
        gameData.filters.searchText = self.elements.searchBox.Text:lower()
        self:updateCharacterList()
        DataManager:save(gameData)
    end)
end

function UIManager:createCharacterList(parent)
    local listContainer = Instance.new("Frame")
    listContainer.Size = UDim2.new(1, -20, 1, -140)
    listContainer.Position = UDim2.new(0, 10, 0, 130)
    listContainer.BackgroundTransparency = 1
    listContainer.Parent = parent
    
    local header = Instance.new("Frame")
    header.Size = UDim2.new(1, 0, 0, 25)
    header.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
    header.BorderSizePixel = 0
    header.Parent = listContainer
    
    local headerCorner = Instance.new("UICorner")
    headerCorner.CornerRadius = UDim.new(0, 6)
    headerCorner.Parent = header
    
    local headerText = Instance.new("TextLabel")
    headerText.Name = "CharacterCountLabel"
    headerText.Size = UDim2.new(1, -10, 1, 0)
    headerText.Position = UDim2.new(0, 10, 0, 0)
    headerText.BackgroundTransparency = 1
    headerText.Text = "Characters (0)"
    headerText.TextColor3 = Color3.fromRGB(200, 200, 255)
    headerText.Font = Enum.Font.GothamBold
    headerText.TextSize = 12
    headerText.TextXAlignment = Enum.TextXAlignment.Left
    headerText.Parent = header
        
    local scrollFrame = Instance.new("ScrollingFrame")
    scrollFrame.Name = "CharacterScroll"
    scrollFrame.Size = UDim2.new(1, 0, 1, -30)
    scrollFrame.Position = UDim2.new(0, 0, 0, 30)
    scrollFrame.BackgroundTransparency = 1
    scrollFrame.BorderSizePixel = 0
    scrollFrame.ScrollBarThickness = 6
    scrollFrame.ScrollBarImageColor3 = Color3.fromRGB(100, 100, 120)
    scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
    scrollFrame.Parent = listContainer
    
    self.elements.characterScroll = scrollFrame
    self.elements.characterItems = {}
    self.elements.characterCountLabel = headerText
    
    self:populateCharacterList()
end

function UIManager:populateCharacterList()
    local scrollFrame = self.elements.characterScroll
    
    for i, charName in ipairs(characterNames) do
        local charData = COMPLETE_DATABASE[charName]
        
        local itemFrame = Instance.new("Frame")
        itemFrame.Name = charName:gsub("%s+", "_")
        itemFrame.Size = UDim2.new(1, -10, 0, 32)
        itemFrame.Position = UDim2.new(0, 5, 0, (i-1) * 34)
        itemFrame.BackgroundColor3 = i % 2 == 0 and Color3.fromRGB(32, 32, 42) or Color3.fromRGB(28, 28, 38)
        itemFrame.BorderSizePixel = 0
        itemFrame.Parent = scrollFrame
        
        local itemCorner = Instance.new("UICorner")
        itemCorner.CornerRadius = UDim.new(0, 6)
        itemCorner.Parent = itemFrame
        
        local rarityStripe = Instance.new("Frame")
        rarityStripe.Size = UDim2.new(0, 4, 1, 0)
        rarityStripe.BackgroundColor3 = RARITY_COLORS[charData.rarity]
        rarityStripe.BorderSizePixel = 0
        rarityStripe.Parent = itemFrame
        
        local stripeCorner = Instance.new("UICorner")
        stripeCorner.CornerRadius = UDim.new(0, 2)
        stripeCorner.Parent = rarityStripe
        
        local checkbox = Instance.new("TextButton")
        checkbox.Size = UDim2.new(0, 20, 0, 20)
        checkbox.Position = UDim2.new(0, 10, 0.5, -10)
        checkbox.BackgroundColor3 = Color3.fromRGB(50, 205, 50)
        checkbox.Text = "‚úì"
        checkbox.TextColor3 = Color3.fromRGB(255, 255, 255)
        checkbox.Font = Enum.Font.GothamBold
        checkbox.TextSize = 12
        checkbox.BorderSizePixel = 0
        checkbox.Parent = itemFrame
        
        local checkCorner = Instance.new("UICorner")
        checkCorner.CornerRadius = UDim.new(0, 4)
        checkCorner.Parent = checkbox
        
        local nameContainer = Instance.new("Frame")
        nameContainer.Size = UDim2.new(1, -80, 1, 0)
        nameContainer.Position = UDim2.new(0, 35, 0, 0)
        nameContainer.BackgroundTransparency = 1
        nameContainer.Parent = itemFrame
        
        local displayName = charName
        if charData.mutation then
            displayName = charData.mutation:sub(1,1) .. ". " .. charName:gsub("^" .. charData.mutation .. " ", "")
        end
        
        local nameLabel = Instance.new("TextLabel")
        nameLabel.Size = UDim2.new(1, -25, 0.6, 0)
        nameLabel.BackgroundTransparency = 1
        nameLabel.Text = displayName
        nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        nameLabel.Font = Enum.Font.Gotham
        nameLabel.TextSize = 11
        nameLabel.TextXAlignment = Enum.TextXAlignment.Left
        nameLabel.TextTruncate = Enum.TextTruncate.AtEnd
        nameLabel.Parent = nameContainer
        
        local infoLabel = Instance.new("TextLabel")
        infoLabel.Size = UDim2.new(1, -25, 0.4, 0)
        infoLabel.Position = UDim2.new(0, 0, 0.6, 0)
        infoLabel.BackgroundTransparency = 1
        infoLabel.Text = charData.rarity .. " ‚Ä¢ Tier " .. charData.tier
        infoLabel.TextColor3 = RARITY_COLORS[charData.rarity]
        infoLabel.Font = Enum.Font.Gotham
        infoLabel.TextSize = 9
        infoLabel.TextXAlignment = Enum.TextXAlignment.Left
        infoLabel.Parent = nameContainer
        
        if charData.mutation then
            local mutationIcon = Instance.new("Frame")
            mutationIcon.Size = UDim2.new(0, 18, 0, 18)
            mutationIcon.Position = UDim2.new(1, -22, 0.5, -9)
            mutationIcon.BackgroundColor3 = MUTATION_COLORS[charData.mutation]
            mutationIcon.BorderSizePixel = 0
            mutationIcon.Parent = itemFrame
            
            local mutationCorner = Instance.new("UICorner")
            mutationCorner.CornerRadius = UDim.new(1, 0)
            mutationCorner.Parent = mutationIcon
            
            local mutationLabel = Instance.new("TextLabel")
            mutationLabel.Size = UDim2.new(1, 0, 1, 0)
            mutationLabel.BackgroundTransparency = 1
            mutationLabel.Text = charData.mutation:sub(1,1)
            mutationLabel.TextColor3 = Color3.fromRGB(0, 0, 0)
            mutationLabel.Font = Enum.Font.GothamBold
            mutationLabel.TextSize = 10
            mutationLabel.Parent = mutationIcon
        end
        
        self.elements.characterItems[charName] = {
            frame = itemFrame,
            checkbox = checkbox,
            nameLabel = nameLabel,
            infoLabel = infoLabel
        }
        
        local isEnabled = gameData.characters[charName].enabled
        checkbox.BackgroundColor3 = isEnabled and Color3.fromRGB(50, 205, 50) or Color3.fromRGB(120, 120, 120)
        checkbox.Text = isEnabled and "‚úì" or ""

        checkbox.MouseButton1Click:Connect(function()
            local enabled = gameData.characters[charName].enabled
            gameData.characters[charName].enabled = not enabled
            
            checkbox.BackgroundColor3 = gameData.characters[charName].enabled and Color3.fromRGB(50, 205, 50) or Color3.fromRGB(120, 120, 120)
            checkbox.Text = gameData.characters[charName].enabled and "‚úì" or ""
            
            self:updateTrackingCount()
            self:updateMainPanel()
            DataManager:save(gameData)
        end)
    end
    
    scrollFrame.CanvasSize = UDim2.new(0, 0, 0, #characterNames * 34)
end

function UIManager:updateCharacterList()
            if not self.elements.characterItems then return end
            
            local visibleCount = 0
            local searchText = gameData.filters.searchText
            local exactMatch = gameData.filters.exactMatch
            local rarityFilter = gameData.filters.selectedRarity
            local mutationFilter = gameData.filters.selectedMutation
            local enabledOnly = gameData.filters.enabledOnly
            
            for _, charName in ipairs(characterNames) do
                local item = self.elements.characterItems[charName]
                if not item then continue end
                
                local charData = COMPLETE_DATABASE[charName]
                local trackData = gameData.characters[charName]
                local shouldShow = true
                
                if searchText ~= "" then
                    local nameToSearch = charName:lower()
                    local baseCharToSearch = charData.baseChar:lower()
                    
                    if exactMatch then
                        shouldShow = (nameToSearch == searchText) or (baseCharToSearch == searchText) or (nameToSearch:find(searchText, 1, true))
                    else
                        shouldShow = nameToSearch:find(searchText, 1, true) ~= nil or baseCharToSearch:find(searchText, 1, true) ~= nil
                    end
                end
                
                if shouldShow and rarityFilter and rarityFilter ~= "All" then
                    shouldShow = charData.rarity == rarityFilter
                end
                
                if shouldShow and mutationFilter and mutationFilter ~= "All" then
                    if mutationFilter == "Base" then
                        shouldShow = charData.mutation == nil
                    else
                        shouldShow = charData.mutation == mutationFilter
                    end
                end
                
                if shouldShow and enabledOnly then
                    shouldShow = trackData.enabled
                end
                
                if shouldShow then
                    item.frame.Visible = true
                    item.frame.Position = UDim2.new(0, 5, 0, visibleCount * 34)
                    visibleCount = visibleCount + 1
                else
                    item.frame.Visible = false
                end
            end
            
            GameState.trackingDisplayed = visibleCount
            self.elements.characterCountLabel.Text = "Characters (" .. GameState.trackingDisplayed .. ")"
            self.elements.characterScroll.CanvasSize = UDim2.new(0, 0, 0, visibleCount * 34)
            self:updateFooter()
        end

        function UIManager:createMainPanel()
            local mainPanel = Instance.new("Frame")
            mainPanel.Name = "MainPanel"
            mainPanel.Size = UDim2.new(1, -350, 1, -115)  -- Adjusted bottom margin from -110 to -115
            mainPanel.Position = UDim2.new(0, 340, 0, 70)
            mainPanel.BackgroundColor3 = Color3.fromRGB(20, 20, 28)
            mainPanel.BorderSizePixel = 0
            mainPanel.Parent = self.elements.mainFrame
            
            local panelCorner = Instance.new("UICorner")
            panelCorner.CornerRadius = UDim.new(0, 12)
            panelCorner.Parent = mainPanel
                local panelStroke = Instance.new("UIStroke")
            panelStroke.Color = Color3.fromRGB(60, 60, 80)
            panelStroke.Thickness = 1
            panelStroke.Transparency = 0.6
            panelStroke.Parent = mainPanel
            
            self:createTrackingHeader(mainPanel)
            self:createTrackingArea(mainPanel)
            
            self.elements.mainPanel = mainPanel
        end

        function UIManager:createTrackingHeader(parent)
            local header = Instance.new("Frame")
            header.Size = UDim2.new(1, -20, 0, 35)
            header.Position = UDim2.new(0, 10, 0, 10)
            header.BackgroundColor3 = Color3.fromRGB(25, 25, 40)
            header.BorderSizePixel = 0
            header.Parent = parent
            
            local headerCorner = Instance.new("UICorner")
            headerCorner.CornerRadius = UDim.new(0, 8)
            headerCorner.Parent = header
            
            local columns = {
                {text = "Character", width = 0.3, align = "Left"},
                {text = "Status", width = 0.12, align = "Center"},
                {text = "Current", width = 0.1, align = "Center"},
                {text = "Total", width = 0.1, align = "Center"},
                {text = "Session", width = 0.1, align = "Center"},
                {text = "Last Seen", width = 0.15, align = "Center"},
                {text = "Priority", width = 0.13, align = "Center"}
            }
            
            local xOffset = 0
            for _, col in ipairs(columns) do
                local label = Instance.new("TextLabel")
                label.Size = UDim2.new(col.width, -5, 1, 0)
                label.Position = UDim2.new(xOffset, 5, 0, 0)
                label.BackgroundTransparency = 1
                label.Text = col.text
                label.TextColor3 = Color3.fromRGB(200, 200, 255)
                label.Font = Enum.Font.GothamBold
                label.TextSize = 11
                label.TextXAlignment = col.align == "Left" and Enum.TextXAlignment.Left or Enum.TextXAlignment.Center
                label.Parent = header
                
                xOffset = xOffset + col.width
            end
        end

        function UIManager:createTrackingArea(parent)
            local scrollFrame = Instance.new("ScrollingFrame")
            scrollFrame.Name = "TrackingScroll"
            scrollFrame.Size = UDim2.new(1, -20, 1, -55)
            scrollFrame.Position = UDim2.new(0, 10, 0, 45)
            scrollFrame.BackgroundTransparency = 1
            scrollFrame.BorderSizePixel = 0
            scrollFrame.ScrollBarThickness = 8
            scrollFrame.ScrollBarImageColor3 = Color3.fromRGB(80, 80, 100)
            scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
            scrollFrame.Parent = parent
            
            self.elements.trackingScroll = scrollFrame
            self.elements.trackingRows = {}
            
            self:populateTrackingRows()
        end

        function UIManager:populateTrackingRows()
            local scrollFrame = self.elements.trackingScroll
            local rowHeight = 30
            local visibleRows = 0
            
            for _, charName in ipairs(characterNames) do
                local charData = COMPLETE_DATABASE[charName]
                local trackData = gameData.characters[charName]
                
                if trackData.enabled then
                    local row = Instance.new("Frame")
                    row.Name = charName:gsub("%s+", "_") .. "_Row"
                    row.Size = UDim2.new(1, -5, 0, rowHeight - 2)
                    row.Position = UDim2.new(0, 0, 0, visibleRows * rowHeight)
                    row.BackgroundColor3 = visibleRows % 2 == 0 and Color3.fromRGB(30, 30, 42) or Color3.fromRGB(25, 25, 35)
                    row.BorderSizePixel = 0
                    row.Parent = scrollFrame
                    
                    local rowCorner = Instance.new("UICorner")
                    rowCorner.CornerRadius = UDim.new(0, 6)
                    rowCorner.Parent = row
                    
                    local rarityStripe = Instance.new("Frame")
                    rarityStripe.Size = UDim2.new(0, 3, 1, -4)
                    rarityStripe.Position = UDim2.new(0, 2, 0, 2)
                    rarityStripe.BackgroundColor3 = RARITY_COLORS[charData.rarity]
                    rarityStripe.BorderSizePixel = 0
                    rarityStripe.Parent = row
                    
                    local stripeCorner = Instance.new("UICorner")
                    stripeCorner.CornerRadius = UDim.new(0, 1)
                    stripeCorner.Parent = rarityStripe
                    
                    local nameContainer = Instance.new("Frame")
                    nameContainer.Size = UDim2.new(0.3, -10, 1, 0)
                    nameContainer.Position = UDim2.new(0, 8, 0, 0)
                    nameContainer.BackgroundTransparency = 1
                    nameContainer.Parent = row
                    
                    local displayName = charName
                    if charData.mutation then
                        displayName = charData.mutation:sub(1,1) .. ". " .. charName:gsub("^" .. charData.mutation .. " ", "")
                    end
                    
                    local nameLabel = Instance.new("TextLabel")
                    nameLabel.Size = UDim2.new(1, -20, 1, 0)
                    nameLabel.BackgroundTransparency = 1
                    nameLabel.Text = displayName
                    nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
                    nameLabel.Font = Enum.Font.Gotham
                    nameLabel.TextSize = 10
                    nameLabel.TextXAlignment = Enum.TextXAlignment.Left
                    nameLabel.TextTruncate = Enum.TextTruncate.AtEnd
                    nameLabel.Parent = nameContainer
                    
                    if charData.mutation then
                        local mutIcon = Instance.new("Frame")
                        mutIcon.Size = UDim2.new(0, 12, 0, 12)
                        mutIcon.Position = UDim2.new(1, -15, 0.5, -6)
                        mutIcon.BackgroundColor3 = MUTATION_COLORS[charData.mutation]
                        mutIcon.BorderSizePixel = 0
                        mutIcon.Parent = nameContainer
                        
                        local mutCorner = Instance.new("UICorner")
                        mutCorner.CornerRadius = UDim.new(1, 0)
                        mutCorner.Parent = mutIcon
                    end
                    
                    local statusContainer = Instance.new("Frame")
                    statusContainer.Size = UDim2.new(0.12, 0, 1, 0)
                    statusContainer.Position = UDim2.new(0.3, 0, 0, 0)
                    statusContainer.BackgroundTransparency = 1
                    statusContainer.Parent = row
                    
                    local statusDot = Instance.new("Frame")
                    statusDot.Size = UDim2.new(0, 10, 0, 10)
                    statusDot.Position = UDim2.new(0.5, -5, 0.5, -5)
                    statusDot.BackgroundColor3 = Color3.fromRGB(120, 120, 120)
                    statusDot.BorderSizePixel = 0
                    statusDot.Parent = statusContainer
                    
                    local dotCorner = Instance.new("UICorner")
                    dotCorner.CornerRadius = UDim.new(1, 0)
                    dotCorner.Parent = statusDot
                    
                    local columns = {
                        {name = "current", pos = 0.42, width = 0.1},
                        {name = "total", pos = 0.52, width = 0.1},
                        {name = "session", pos = 0.62, width = 0.1},
                        {name = "lastSeen", pos = 0.72, width = 0.15},
                        {name = "priority", pos = 0.87, width = 0.13}
                    }
                    
                    local labels = {}
                    for _, col in ipairs(columns) do
                        local label = Instance.new("TextLabel")
                        label.Size = UDim2.new(col.width, -5, 1, 0)
                        label.Position = UDim2.new(col.pos, 0, 0, 0)
                        label.BackgroundTransparency = 1
                        label.Text = col.name == "priority" and string.format("%.1f", (10-charData.tier) * charData.multiplier) or "0"
                        label.TextColor3 = Color3.fromRGB(200, 200, 200)
                        label.Font = Enum.Font.Gotham
                        label.TextSize = 10
                        label.Parent = row
                        
                        labels[col.name] = label
                    end
                    
                    self.elements.trackingRows[charName] = {
                        row = row,
                        statusDot = statusDot,
                        nameLabel = nameLabel,
                        labels = labels
                    }
                    
                    visibleRows = visibleRows + 1
                end
            end
            
            scrollFrame.CanvasSize = UDim2.new(0, 0, 0, visibleRows * rowHeight)
        end

        function UIManager:updateMainPanel()
            if not self.elements.trackingScroll then return end
            
            for _, child in pairs(self.elements.trackingScroll:GetChildren()) do
                if child:IsA("Frame") then
                    child:Destroy()
                end
            end
            
            self.elements.trackingRows = {}
            self:populateTrackingRows()
        end

        function UIManager:createFooter()
            local footer = Instance.new("Frame")
            footer.Name = "Footer"
            footer.Size = UDim2.new(1, 0, 0, 35)  -- Reduced from 40 to 35
            footer.Position = UDim2.new(0, 0, 1, -35)  -- Updated position
            footer.BackgroundColor3 = Color3.fromRGB(15, 15, 22)
            footer.BorderSizePixel = 0
            footer.Parent = self.elements.mainFrame
            
            local footerCorner = Instance.new("UICorner")
            footerCorner.CornerRadius = UDim.new(0, 16)
            footerCorner.Parent = footer
            
            local cornerFix = Instance.new("Frame")
            cornerFix.Size = UDim2.new(1, 0, 0, 16)
            cornerFix.BackgroundColor3 = Color3.fromRGB(15, 15, 22)
            cornerFix.BorderSizePixel = 0
            cornerFix.Parent = footer
            
            local statusContainer = Instance.new("Frame")
            statusContainer.Size = UDim2.new(1, -40, 1, -8)  -- Reduced padding
            statusContainer.Position = UDim2.new(0, 20, 0, 4)  -- Adjusted position
            statusContainer.BackgroundTransparency = 1
            statusContainer.Parent = footer
            
            local statusItems = {
                {name = "lastUpdate", text = "Updated: Now", pos = 0},
                {name = "sessionInfo", text = "Session: 0m", pos = 0.2},
                {name = "performance", text = "FPS: 60", pos = 0.5},
                {name = "tracking", text = "Tracking: 0/0", pos = 0.75}
            }
            
            for _, item in ipairs(statusItems) do
                local label = Instance.new("TextLabel")
                label.Name = item.name
                label.Size = UDim2.new(0.25, -10, 1, 0)
                label.Position = UDim2.new(item.pos, 0, 0, 0)
                label.BackgroundTransparency = 1
                label.Text = item.text
                label.TextColor3 = Color3.fromRGB(150, 150, 170)
                label.Font = Enum.Font.Gotham
                label.TextSize = 10
                label.TextXAlignment = Enum.TextXAlignment.Left
                label.Parent = statusContainer
                
                self.elements[item.name] = label
            end
        end

        function UIManager:makeDraggable()
            local frame = self.elements.mainFrame
            local handle = self.elements.header
            
            local dragging = false
            local dragInput, dragStart, startPos
            
            local function update(input)
                local delta = input.Position - dragStart
                frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
            end
            
            handle.InputBegan:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                    dragging = true
                    dragStart = input.Position
                    startPos = frame.Position

                    input.Changed:Connect(function()
                        if input.UserInputState == Enum.UserInputState.End then
                            dragging = false
                        end
                    end)
                end
            end)

            handle.InputChanged:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
                    dragInput = input
                end
            end)
            
            Services.UserInputService.InputChanged:Connect(function(input)
                if input == dragInput and dragging then
                    update(input)
                end
            end)
        end

        function UIManager:updateTrackingCount()
            local enabledCount = 0
            local totalCount = 0
                for _, charName in ipairs(characterNames) do
                local trackData = gameData.characters[charName]
                if trackData.enabled then
                    enabledCount = enabledCount + 1
                end
                totalCount = totalCount + 1
            end
            
            GameState.trackingEnabled = enabledCount
            GameState.trackingTotal = totalCount
            self:updateFooter()
        end

        function UIManager:updateFooter()
            if self.elements.lastUpdate then
                self.elements.lastUpdate.Text = "Updated: " .. os.date("%X", GameState.lastUpdateTime)
            end
            
            if self.elements.sessionInfo then
                local now = os.time()
                local sessionTime = now - GameState.joinTime
                
                local hours = math.floor(sessionTime / 3600)
                local minutes = math.floor((sessionTime % 3600) / 60)
                local seconds = sessionTime % 60
                
                if hours > 0 then
                    self.elements.sessionInfo.Text = string.format("Session: %dh %dm %ds", hours, minutes, seconds)
                elseif minutes > 0 then
                    self.elements.sessionInfo.Text = string.format("Session: %dm %ds", minutes, seconds)
                else
                    self.elements.sessionInfo.Text = string.format("Session: %ds", seconds)
                end
            end
            
            if self.elements.performance then
                self.elements.performance.Text = string.format("FPS: %d", math.floor(GameState.averageFPS))
            end
            
            if self.elements.tracking then
                self.elements.tracking.Text = string.format("Tracking: %d/%d", GameState.trackingEnabled, GameState.trackingDisplayed)
            end
        end

        local CharacterTracker = {
            instances = {},
            previousCounts = {},
            scanCache = {},
            lastScan = 0
        }

        function CharacterTracker:scanWorkspace()
            local now = tick()
            if now - self.lastScan < 0.1 then
                return self.scanCache
            end
            
            self.lastScan = now
            self.scanCache = {}
            
            local workspaceChildren = workspace:GetChildren()
            for _, obj in pairs(workspaceChildren) do
                if obj:IsA("Model") and COMPLETE_DATABASE[obj.Name] then
                    if not self.scanCache[obj.Name] then
                        self.scanCache[obj.Name] = {}
                    end
                    table.insert(self.scanCache[obj.Name], obj)
                end
            end
            
            return self.scanCache
        end

        function CharacterTracker:getCharacterCount(charName)
            local cache = self:scanWorkspace()
            local list = cache[charName]
            return list and #list or 0
        end

        function CharacterTracker:updateCharacterStates(deltaTime)
            deltaTime = deltaTime or CONFIG.UPDATE_INTERVAL

            for _, charName in ipairs(characterNames) do
                -- Ensure character entry exists
                local trackData = gameData.characters[charName]
                if not trackData then
                    gameData.characters[charName] = {
                        enabled = false,
                        totalSeen = 0,
                        currentCount = 0,
                        status = "never",
                        lastSeen = 0,
                        sessionSpawns = 0,
                        totalTime = 0
                    }
                    trackData = gameData.characters[charName]
                end

                if trackData.enabled then
                    local currentCount = self:getCharacterCount(charName)
                    if currentCount > 0 then
                        if trackData.status ~= "active" then
                            trackData.status = "active"
                            trackData.sessionSpawns = trackData.sessionSpawns + 1
                            trackData.totalSeen = trackData.totalSeen + 1
                            trackData.lastSeen = os.time()
                            
                            -- Send webhook notification for character spawn
                            local charData = COMPLETE_DATABASE[charName]
                            if charData and charData.rarity then
                                local rarity = charData.rarity
                                if rarity == "Secret" or rarity == "Awakened" or rarity == "Mythic" or rarity == "Legendary" then
                                    WebhookManager:notifyCharacterSpawn(charName, rarity, game.JobId)
                                end
                            end
                        end
                        trackData.currentCount = currentCount
                        trackData.totalTime = trackData.totalTime + deltaTime
                    else
                        if trackData.status ~= "inactive" then
                            trackData.status = "inactive"
                        end
                        trackData.currentCount = 0
                    end
                else
                    trackData.status = "disabled"
                    trackData.currentCount = 0
                end

                -- Live-update the UI row if present
                self:updateCharacterUI(charName)
            end

            DataManager:save(gameData)
        end

        function CharacterTracker:updateCharacterUI(charName)
            local trackData = gameData.characters[charName]
            local charData = COMPLETE_DATABASE[charName]
            local row = UIManager.elements.trackingRows[charName]
            if not row or not trackData or not charData then return end

            local statusColor
            if trackData.status == "active" then
                statusColor = Color3.fromRGB(76, 175, 80)      -- green
            elseif trackData.status == "inactive" then
                statusColor = Color3.fromRGB(244, 67, 54)      -- red
            else
                statusColor = Color3.fromRGB(158, 158, 158)    -- gray (disabled/never)
            end
            row.statusDot.BackgroundColor3 = statusColor

            row.labels.current.Text = tostring(trackData.currentCount)
            row.labels.total.Text = tostring(trackData.totalSeen)
            row.labels.session.Text = tostring(trackData.sessionSpawns)

            if trackData.lastSeen > 0 then
                local elapsed = os.time() - trackData.lastSeen
                if elapsed < 60 then
                    row.labels.lastSeen.Text = string.format("%ds", elapsed)
                elseif elapsed < 3600 then
                    row.labels.lastSeen.Text = string.format("%dm", math.floor(elapsed / 60))
                else
                    row.labels.lastSeen.Text = string.format("%dh", math.floor(elapsed / 3600))
                end
            else
                row.labels.lastSeen.Text = "Never"
            end

            row.labels.priority.Text = string.format("%d", charData.income or 0)
        end

        local function initialize()
        print("[UnluckysHub] Initializing...")

        -- Load saved data or fallback to defaults
        gameData = DataManager:load() or DataManager:getDefaultData()

        -- Safety: ensure characters table exists
        gameData.characters = gameData.characters or {}
        
        -- Safety: ensure settings exist with defaults
        gameData.settings = gameData.settings or {}
        gameData.settings.autoLockEnabled = gameData.settings.autoLockEnabled or false
        gameData.settings.autoCollectEnabled = gameData.settings.autoCollectEnabled or false
        gameData.settings.autoBuyEnabled = gameData.settings.autoBuyEnabled or false
        gameData.settings.soundEnabled = gameData.settings.soundEnabled or true
        gameData.settings.performanceMode = gameData.settings.performanceMode or false

        -- Update tracking total based on available character names
        GameState.trackingTotal = #characterNames

        -- Create UI
        UIManager:create()
        UIManager:updateTrackingCount()
        UIManager:updateCharacterList()

        -- Initialize auto systems with saved states
        print("[UnluckysHub] Initializing auto systems...")
        
        if gameData.settings.autoLockEnabled then
            print("[UnluckysHub] Restoring Auto Lock system...")
            AutoLock:toggle()
        end

        if gameData.settings.autoCollectEnabled then
            print("[UnluckysHub] Restoring Auto Collect system...")
            AutoCollect:toggle()
        end
        
        if gameData.settings.autoBuyEnabled then
            print("[UnluckysHub] Restoring Auto Buy system...")
            AutoBuySystem:toggle()
        end

        -- Send script execution notification
        WebhookManager:notifyScriptExecution()

        -- Delay starting the tracker so UI builds first
        task.delay(0.5, function()
            GameState.scriptActive = true
            CharacterTracker:updateCharacterStates()
            print("[UnluckysHub] Initialization complete.")
            print("[UnluckysHub] Tracking " .. tostring(GameState.trackingEnabled) .. " characters.")
            print("[UnluckysHub] Auto Lock: " .. (gameData.settings.autoLockEnabled and "ON" or "OFF"))
            print("[UnluckysHub] Auto Collect: " .. (gameData.settings.autoCollectEnabled and "ON" or "OFF"))
            print("[UnluckysHub] Auto Buy: " .. (gameData.settings.autoBuyEnabled and "ON" or "OFF"))
        end)
    end

        -- Main update loop to keep tracker and UI refreshed
        local function mainUpdate(deltaTime)
            local now = tick()

            if GameState.scriptActive and (now - GameState.lastUpdate) >= CONFIG.UPDATE_INTERVAL then
                GameState.lastUpdate = now
                GameState.lastUpdateTime = os.time()

                -- Update character states and footer
                CharacterTracker:updateCharacterStates(deltaTime)
                UIManager:updateFooter()
            end

            -- Update performance metrics
            PerformanceMonitor:update(deltaTime)
        end

        -- Connect to RunService.Heartbeat for continuous updates
        Services.RunService.Heartbeat:Connect(function(deltaTime)
            mainUpdate(deltaTime)
        end)

        task.wait(2)
        initialize()
